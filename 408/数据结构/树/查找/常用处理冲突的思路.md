---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---

## [常用处理冲突的思路](zotero://select/library/items/TBDK2BKB)
- 换个位置: ==开放==地址法
^1662441229294
- 同一位置的冲突对象组织在一起: ==链==地址法
^1662441229320

如果按照相反的顺序插入各个元素,元素在散列表中的位置是否一样? :: 不一样 ^1662441229325

处理散列冲突的常用方法有:==开放定址法==,==链地址法==,==公共溢出区==
^1667789233401

### 开放定址法(Open Addressing)
若发生了第 i 次冲突，试探的下一个地址将增加$d_i$，基本公式是 #card
$$h_i(key) = (h(key)+d_i)\quad mod\quad TableSize ( 1\le i < TableSize )$$
散列表的地址空间大小是一个不小于TableSize的素数
^1662441229330

开放定址法根据$d_i$ 决定了不同的解决冲突方案:{线性探测}、{平方探测}、{双散列}。
^1662441229333

开放定址法的线性探测法$d_i=?$ :: $d_i=i$ ^1662441229345
开放定址法的平方探测法$d_i=?$ :: $d_i=\pm i^2$ ^1662441229348
开放定址法的双散列法$d_i=?$ :: $d_i=i\times h_2(key)$ ^1662441229353

在开放地址散列表中，{1:删除}操作要很小心。通常只能“{2:懒惰删除}”，即需要增加一个“ {2:删除标记(Deleted)}”，而并不是真正删除它。以便查找时不会“{3:断链}”。其空间可以在下次插入时{4:重用}。
^1662441229356

在开放地址散列表中,能不能进行标准的删除操作?:: 不能 ^1662441229358
为什么在开放地址散列表中,不能进行标准的删除操作? :: 因为相应的单元可能已引起过冲突,数据已绕过它存在其他地方 ^1662441229362


#### 线性探测法(Linear Probing)
线性探测法:以增量序列 $1，2，\cdots\cdots，(TableSize -1)$ 循环试探下一个存储地址
![[Pasted image 20220809201939.png]]
![[Pasted image 20220809201955.png]]
#card-spaced 
^1662441229365


插入某个元素需要经过多次冲突才能找到空位置,称为==聚集==
^1662441229368
线性探测法可能出现什么现象? :: 聚集现象 ^1662441229370

散列表如何计算ASL(平均查找长度) #card 
每个 关键词的比较次数=冲突次数+1
P178
^1662441229373



#### 平方探测法(Quadratic Probing)
二次探测
![[Pasted image 20220809202248.png]]
![[Pasted image 20220809202256.png]]
#card-spaced 
^1662441229376

是否有空间，平方探测(二次探测)就能找得到? 
![[Pasted image 20220809202441.png]]
有定理显示:如果散列表长度TableSize是某个{1:4k+3}(k是正整数)形式的{1:素数}时，平方探测法就可以探查到{2:整个}散列表空间
^1662441229379


#### 双散列探测法
(Double Hashing)
双散列探测法: $d_i$为$i\times h_2(key)$，$h_2(key)$是另一个散列函数
探测序列成:$h_2(key)，2h_2(key)，3h_2(key)，\cdots\cdots$

- 对任意的key，h2(key) $\ne 0$ 
- 探测序列还应该保证**所有的散列存储单元**都应该能够被**探测到**。选择以下形式有良好的效果:$h_2(key) = p - (key\quad mod\quad p)$其中:p < TableSize，p、TableSize都是素数。

双散列探测法的第二个散列函数能否为空? :: 不能 ^1662441229383
双散列探测法的第二个散列函数公式为? :: $h_2(key) = p - (key\quad mod\quad p)$其中:p < TableSize，p、TableSize都是素数。 ^1662441229386


### 分离链接法(Separate Chaining)
分离链接法:将相应位置上冲突的所有关键词存储在同一个==单链表==中
^1662441229391
![[Pasted image 20220809203044.png]]
![[Pasted image 20220809203054.png]]


## [[散列表的性能分析]]
