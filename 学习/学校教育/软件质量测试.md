---
tags: 软件质量测试   [obsidian]
cards-deck: 大三下::软件质量测试
---

概念不需要死记硬背，大体一致就可以。
期末考试50分，加上平时分可以及格。

# 第一章
（第一章）软件质量的概念，软件质量保证 ，软件测试 （第9章）

什么是软件质量是？ #card 
系统、部件或者过程
1. 满足**规定需求的程度**。
2. 满足**需要或期望的程度**
^1651409346520


软件质量保证(Software Quality Assurance,SQA).是一种应用于整个软件过程的保护性活动

什么是软件质量保证？ #card 
SQA；是一种应用于**整个软件过程**的**保护性活动**
^1651409346530

软件测试是使用人工或自动手段来运行或测定某个系统的过程，检验它是否满足规定的需求 或者弄清预期结果与实际结果之间的差别。
软件测试是为了尽快尽早地发现在软件产品中所存在的各种软件缺陷而展开的贯穿整个软件开发生命周期、对软件产品(包括阶段性产品)进行验证和确认的活动过程。


# 第二章
（第二章）什么是质量控制，质量控制的过程P40（PDCA）

软件质量控制是一组由开发组织使用的程序和方法，使用它可在规定的资金投入和时间限制的条件下，提供满足客户质量要求的软件产品并持续不断地改善开发过程和开发组织本身，以提高将来生产高质量软件产品的能力。

软件质量控制的目标是以最低的代价获得客户满意的软件产品。
软件质量控制的另一个目标是从每一次开发过程中学习以便使软件质量控制一次比一次更好(软件过程改善)

什么是软件质量控制？ #card 
一组由开发组织使用的程序和方法；用它可以满足客户的质量需求，能提高生产软件产品的能力，改善开发过程和开发组织本身
^1651409346534

软件质量控制的目标是 :: 以**最低的代价**获得客户满意的**软件产品** ^1651409346538

软件质量控制的实施过程
![[Pasted image 20220501102249.png]]


软件质量控制的实施过程 #card 
1. 预开发阶段
2. 开发阶段
3. 维护阶段
每一个阶段均为PDCA循环
![[Pasted image 20220501102600.png]]
marginnote3app://note/7940F2F4-B84A-4736-85E6-2500295953C7
^1651409346542


PDCA循环的含义是将质量管理分为四个阶段，即PIan(计划)、Do(执行)、Check(检查)和Act(处理)

PDCA循环中的PDCA分别表示的含义是？ #card 
- PIan(计划)
- Do(执行)
- Check(检查)
- Act(处理)
![[Pasted image 20220501102745.png]]
^1651409346553


# 第3章
（第三章）质量保证的模型（McCall模型）P56，三方面（修正、转移、运行）的特性，配置管理P63，CMM能力成熟度模型
（第五章）能力成熟度模型（对5个等级的特征P103）---\[关键域\]

质量模型是一组特性与特性之间的关系，是软件质量评价的指标体系。
## Mcall模型
McCall 质量模型使用 3 种视角:**产品运行、产品修正、产品转移**来定义和识别软件产品的质量
具有11个特性
1. **正确性:程序满足需求规约和实现用户任务目标的程度。** 
2. 可靠性:程序满足所需的精确度完成预期功能的程度
3. 效率:程序完成其功能所需的计算资源和代码的度量。 
4. **完整性:对未授权人员访问软件或数据的可控制程度。** 
5. **可用性:学习、操作、准备输入和解释程序输出所需的工作量。** 
6. 可维护性:定位和修复程序中的错误所需的工作量。 
7. **灵活性:修改运行的程序所需的工作量**
8. **可测试性:测试程序，确保完成所期望的功能所需的工作量。** 
9. 可移植性:把程序从一个硬件和或软件系统环境移植到另一个环境所需的工作量。 
10. **互连性:连接一个系统和另一个系统所需的工作量。**
11. **可复用性：程序可以在另外一个应用程序中复用的程度**
![[Pasted image 20220501103215.png]]
marginnote3app://note/7B23E141-6203-46AE-9D25-B6E8C41ED66B

Mcall模型的三大特性是？ #card 
**产品运行、产品修正、产品转移**
^1651409346556

Mcall模型的十一大特性有？ #card 
![[Pasted image 20220501103215.png]]
^1651409346560

什么是Mcall模型的完整性？ :: 对未授权人员访问软件或数据的可控制程度 ^1651409346563
什么是Mcall模型的正确性？ :: 程序满足需求规约和实现用户任务目标的程度 ^1651409346567
什么是Mcall模型的可维护性？ :: 定位和修复程序中的错误所需的工作量 ^1651409346570


软件配置管理SCM作为CMM2级的一个关键域(Key Practice Area,KPA),是一种标识、组织、控制修改的技术。在整个软件的开发活动中占有很重要的位置。
marginnote3app://note/63C6B1F4-938D-47D4-B0DA-5A60F8E6C878


软件配置管理的目标:软件配置管理是在贯穿整个软件生命周期中建立和维护项目产品的完整性。
- 软件配置管理的各项工作是有计划进行的。  
- 被选择的项目产品得到识别，控制并且可以被相关人员获取。  
- 已识别出的项目产品的更改得到控制。  
- 使相关组别和个人及时了解软件基准的状态和内容。
marginnote3app://note/9F9862C7-24CC-4C6F-86A0-17C491666FBD

什么是软件配置管理？ #card 
- SCM；
- 贯穿于整个软件过程中的保护性活动
- 作为CMM2级的一个关键域,是一种**标识、组织、控制修改**的技术。
^1651409346575

软件配置管理的目标是？ #card 
- 使软件配置管理的工作能够有计划进行
- 产品能够得到识别，控制，被相关人员获取
- 产品修改能够得到控制
^1651409346578

软件配置管理作为CMM的几级域？ :: CMM2级 ^1651409346583


CMM能力成熟度模型 103页
CMM包括5个等级，共计18个过程域，52个目标，300多个关键实践。
marginnote3app://note/30B8B3DF-4E3A-49C4-ABC2-66217E190754
![[Pasted image 20220501111743.png]]
marginnote3app://note/25C93177-EA57-4DE9-878F-3278B6291E2C
![[Pasted image 20220501120620.png]]
![[Pasted image 20220501112352.png]]
CMM/CMMI 为满足这个关键过程域的要求需要达到以下 4 个目标: 
目标 1:软件质量保证活动是有计划的  
目标 2:软件产品和活动与适用的标准、规程和需求的符合性要得到客观验证 
目标 3:相关的小组和个人要被告知软件质量保证的活动和结果
目标 4:高级管理者处理在软件项目内部不能解决的不符合问题。

CMM有多少个等级？ :: 5 ^1651409346586
CMM共计多少个过程域？ :: 18  ^1651409346590
CMM有多少个目标？ :: 52  ^1651409346594
CMM包括多少个关键实践？ :: 300多 ^1651409346599

CMM从低到高依次是什么等级？ #card 
1. 初始级
2. 可重复级
3. 已定义级
4. 已管理级
5. 优化级
^1651409346603

CMM的初始级的特征是什么？ :: 过程没有定义，控制很差，反应式 ^1651409346607
CMM的可重复级的特征是什么？ :: 过程由具体项目描述，组织是反应式 ^1651409346612
CMM的已定义级的特征是什么？ :: 项目通过组织发展方法，调整过程 ^1651409346617
CMM的已管理级的特征是什么？ :: 过程被检测和控制 ^1651409346620
CMM的优化级的特征是什么？ :: 聚集过程改进 ^1651409346624

软件配置管理属于CMM的什么级的关键域 ？ :: 2级，可重复级 ^1651409346627
如何才能达到可重复级？ :: 必须要有软件配置管理 ^1651409346631

# 第4章
（第四章）可靠性的定义，软件度量
“软件可靠性”一词正式作出了如下定义：
在规定的条件下，在规定的时间内，软件不引起系统失效的概率，该概率是系统输人和系统使用的函数，也是软件中存在的错误的函数，系统输入将确定是否会遇到已存在的错误（如果错误存在）；在规定的时间周期内，在所述条件下，程序执行所要求的功能的能力

什么是软件可靠性？ #card 
在规定的时间周期内，在所述条件下程序执行所要求的功能的能力
^1651409346636

![[Pasted image 20220501122844.png]]
在软件开发中，**软件质量度量的根本目的是为了管理的需要**。利用度量来改进软件过程。人们是无法管堙不能度量的事物
marginnote3app://note/B7584598-FF9E-4C3C-98DB-67F485FF69EE

什么是软件度量？ #card 
对软件开发项目，过程，产品进行数据定义，收集，分析的持续性定量化过程
^1651409346640

软件质量度量的根本目的是:: 为了管理的需要 ^1651409346644

# 第6章
（第六章）评审（静态的--文档、代码）主要内容，为什么需要评审，技术评审（开发文档），评审方法，评审会议

![[Pasted image 20220501124106.png]]
![[Pasted image 20220501124025.png]]

什么是评审？ #card 
用于开发过程中早期检查和纠正缺陷的有效方法，可检查未形成执行代码的文档缺陷。
^1651409346649

评审的目的是？ :: 让大家达成同识 ^1651409346653

什么是软件评审？ :: 在软件的生命周期内所实施的对**软件本身**的评审。 ^1651409346656
为什么需要软件评审？ #card 
- 提高项目的生产率
- 通过评审，标志着软件开发的一个阶段的完成。
- 生产出更容易维护的软件。
^1651409346660


技术评审(目的:发现功能上的错误，验证软件符合它的需求规格)
![[Pasted image 20220501124708.png]]

什么是技术评审？ :: 一种同行审查技术 ^1651409346663
技术评审针对的什么？ :: 对需求文档，源代码，测试用例 ^1651409346668

![[Pasted image 20220501125832.png]]
评审的方法有
1. 正式的
2. 非正式的

评审方法从最随意到最正式的阶段为？  #card 
![[Pasted image 20220501125932.png]]
^1651409346671

会议的目的是？ :: 对评审的总结 ^1651409346674

软件评审和测试的区别 #card 
- 对象: 评审针对文档和开发语言,而测试是针对开发人员设计出的产品.  
- 目的: 评审是让大家达成同识,而测试是找出软件中的缺陷.
^1651409346677


# 第9章
（第九章）软件测试目的、概念、原则，软件测试的方法，单元测试（包括什么）：庄模块、驱动模块P231，测试技术：静态、动态、回归，软件开发和软件测试的关系（按v模型回答）

什么是软件测试？ #card 
使用人工或自动手段来测定某个系统的过程，来检验它**预期结果**与**实际结果**之间的差别
^1651409346681

软件测试目的是？::寻找错误，并且尽可能找出最多的错误 ^1651409346685

![[Pasted image 20220501135124.png]]
软件测试能够证明程序的正确性吗？ :: 不能 ^1651409346688

![[Pasted image 20220501135217.png]]

软件测试的原则有？ #card 
1. 尽早和不断地进行软件测试
2. 不可能穷举测试
3. 不应该编程之后再开展测试，应当贯穿整个软件生命周期
^1651409346691

软件测试可分为:: 静态测试和动态测试 ^1651409346693
什么是静态测试？ :: 不运行被测程序本身，仅通过分析和检查来验证程序的正确性 ^1651409346697
什么是动态测试？ :: 通过运行被测程序，检查运行结果与预期结之间的差异 ^1651409346701

![[Pasted image 20220501173307.png]]
什么是回归测试？ :: 对软件新版本测试时，重复执行之前某一个重要版本的所有测试用例 ^1651409346704

软件测试的阶段包括？ #card 
1. 单元测试
2. 集成测试
3. 系统测试
4. 验收测试
^1651409346707


单元测试:对软件基本组成单元进行测试，主要是为了发现单元内部可能存在的各种错误和不足。

什么是单元测试？ :: 对软件基本组成单元进行测试，发现单元内部可能存在的错误 ^1651409346710
单元测试的主要任务是哪5个部分（5个方面）？ #card 
- 模块接口
- 局部数据结构
- 路径测试
- 错误处理
- 边界条件
![[Pasted image 20220501164049.png]]
^1651409346713


![[Pasted image 20220501140735.png]]

驱动模块和桩模块都是单元测试的额外的开销，虽然在单元测试中必须编写，但并不需要作为最终的产品提供给用户。
驱动模块(Drive)  用来模拟被测试模块的上一级模块，相当于被测模块的主程序。它接收数据，将相关数据传送给被测模块，启动被测模块，并打印出相应的结果。
桩模块(Stub)  用来模拟被测模块工作过程中所调用的模块。它们一般只进行很少的数据处理。

单元测试的环境为（4个）？ #card 
1. 详细设计说明书
2. 源程序清单
3. 驱动模块
4. 桩模块
^1651409346718

什么是驱动模块？ #card 
(Drive)
- 模拟被测试模块的上一级模块，相当于被测模块的**主程序**
- 接收数据，将相关数据传送给**被测模块**，启动被测模块，并**打印出相应的结果**。
![[Pasted image 20220501163852.png]]
^1651409346720

什么是桩模块？ #card 
(Stub)模拟被测模块工作过程中所调用的模块。
![[Pasted image 20220501163852.png]]
^1651409346723


 驱动模块和桩模块都是什么模块? :: 辅助模块；额外开销，实际不需要作为最终的产品提供给用户 ^1651409346726
 驱动模块和桩模块由谁编写的? :: 由测试人员编写 ^1651409346729


谈谈软件开发和软件测试的关系? #card 
v 模型:需求、设计、编码的开发活动随时间而进行，而相应的测试活动开展的次序正好相反。
w 模型（改进v模型）:测试与开发是同步进行的。有利于尽早发现问题
![[Pasted image 20220501165518.png]]
![[Pasted image 20220501165527.png]]
^1651409346734


# 第10章
（第十章）
集成测试
- （箭增式：自底向上，自顶向下，中间横向）
- 特征

面向对象的测试和传统的测试的区别，面向对象测试的层次结构（三个：对认定的对象、对认定的结构、对构造）
性能测试（指标，涉及响应时间，并发用户数）

集成测试:集成测试是在单元测试的基础上，将多个模块组合在一起进行测试的过程，主要检查各个软件单元之间的相互接口是否正确。
![[Pasted image 20220501170538.png]]
![[Pasted image 20220501170546.png]]

集成测试的策略分为：
- 渐增式集成
	1. 自顶向下增式集成测试
	2. 自底向上增式集成测试
- 非渐增式集成
- 三明治集成测试

三明治集成测试的特征？ #card 
采用自顶向下、自底向上集成**相结合的方式**，并采取**持续集成**的策略，有助于尽早发现缺陷
^1651409346736

非增量式集成测试的特征？ #card 
先分散测试，然后集中起来再一次完成集成测试
^1651409346739

增量式集成测试是自顶向下还是自底向上采用BFS？ ::  自顶向下 ^1651409346742

![[Pasted image 20220501171256.png]]

[面向对象软件测试与传统测试的不同之处](https://blog.csdn.net/m0_61655732/article/details/120939516)
面向对象的测试和传统测试的区别
1. 封装性测试
2. 继承性测试
3. 多态性测试
4. 测试关注的对象不同
	1. 传统测试关注功能模块
	2. 面向对象测试关注一个对象


面向对象测试的层次结构：（3个） #card 
1. 对认定对象的测试
2. 对认定结构的测试
3.  对构造的类层次结构的测试
^1651409346745


# 性能测试
![[Pasted image 20220501173649.png]]

判断性能测试指标有？ #card 
1. 响应时间
2. 并发用户数（吞吐量）
^1651409346749


-   Flat测试：一次性加载用户
-   ramp-up测试：依次加载用户

![[Pasted image 20220501173459.png]]
“Flat”测试: 对于一次给定的测试，应该取响应时间和吞吐量的平均值。精确地获得这些值的唯一方法是一次加载所有的用户，然后在预定的时间段内持续运行。
Ramp-up测试: 用户是交错上升的。ramp-up测试的优点是，可以看出随着系统负载的改变，测量值是如何改变的。然后可以据此选择以后要运行的flat测试的范围。

性能测试中2种负载类型是？ #card 
1. Flat测试
2. ramp-up测试
^1651409346752

什么是flat测试？ :: 一次性加载用户，在预定的时间段内持续运行 ^1651409346754
什么是ramp-up测试？ :: 依次加载用户，可以看出系统负载的变化 ^1651409346757

![[Pasted image 20220501174230.png]]

什么是确定容量的最好方法？ #card
- 结合负载类型的优点，并进行一系统的测试，产生最好的结果
^1651409346760


# 软件缺陷
![[Pasted image 20220501190520.png]]

什么是软件缺陷？ #card 
软件缺陷是系统所需要实现的某种功能的失效或违背。
^1651409346763

软件缺陷类型
![[Pasted image 20220501190754.png]]

软件缺陷类型
- 未达到产品说明书标明的功能
- 出现了产品说明书不会出现的错误
- 未达到产品说明书应当达到的目标
- 超出了产品说明书中指出的范围
- 软件难以使用
#card-spaced 
^1651409346769



# 黑盒测试工具
loadrunner，UFT
1.  原理
2.  loadrunner：性能测试
    1.  通过一个代理Agent，用来监视CS的通讯，C语言录制用户的操作转化为脚本
    2.  构成
        1.  Virtual User Generator（Vugen） 创建脚本
        2.  Controller 设计和运行场景
        3.  Analysis


LoadRunner的工作原理 #card 
通过一个代理Agent，用来**监视CS的通讯**，C语言录制**用户操作**转化为脚本
^1651409346772

LoadRunner能做什么？ #card 
性能测试，测试可控制的峰值
^1651409346775

LoadRunner由什么组件构成？ #card 
1. Virtual User Generator（Vugen）
2. Controller 
3. Analysis
^1651409346778

UFT的工作原理 #card 
用关键词驱动（Keyword-Driven）测试的理念，能完全简化测试的创建和维护工作
^1651409346781

UFT能做什么？ #card 
用于检验应用程序是否**如期运行**的**功能性测试**工具
^1651409346786


# 黑盒测试
![[Pasted image 20220501193830.png]] #card-spaced 
^1651409346790

设计测试用例时，要同时考虑这两种（有效/无效）等价类 #card-spaced 
^1651409346792

等价类的划分原则：

![[Pasted image 20220501194719.png]]

等价类按照区间划分，可分出多少个有效等价类，多少个无效等价类？ :: 1个有效类，2个无效等价类 ^1651409346795



![[Pasted image 20220501194821.png]]

等价类按照数值划分，可分出多少个有效等价类，多少个无效等价类？ ::每一个值有1个有效类，n个无效等价类 ^1651409346799

![[Pasted image 20220501194913.png]]

等价类按照数值集合划分，可分出多少个有效等价类，多少个无效等价类？ ::1个有效类，1个无效等价类 ^1651409346804

![[Pasted image 20220501194940.png]]

等价类按照限制条件/规则划分，可分出多少个有效等价类，多少个无效等价类？ ::1个有效类，若干个无效等价类 ^1651409346807


![[Pasted image 20220501195030.png]]

每一个测试用例应覆盖多少个**有效**等价类？ :: 多个（全部）有效等价类 ^1651409346810
每一个测试用例应覆盖多少个**无效**等价类？ :: 只覆盖1个无效等价类 ^1651409346812

如何做黑盒测试的等价类划分题目？ #card 
1. 先划分有效/无效等价类，编号
2. 写测试用例，覆盖的等价类，预期结果
^1651409346816

![[Pasted image 20220501195557.png]]
![[Pasted image 20220501195609.png]]
![[Pasted image 20220501195619.png]]


## 健壮性，一般性等价类
![[Pasted image 20220501200217.png]]
![[Pasted image 20220501200349.png]]

![[Pasted image 20220501201040.png]]

![[Pasted image 20220501201035.png]]
![[Pasted image 20220501201131.png]]
#card-spaced 
^1651409346819


1. 弱一般等价类测试用例覆盖了所有的**有效等价类的一个值**
2. 强一般等价类测试用例覆盖了所有的有效等价类的全排列
3. 弱健壮性等价类需要考虑无效输入（利用一个无效，其余有效）
4. 强健壮性等价类需要考虑无效输入（用全排列）
#card-spaced 
^1651409346821

## 边界值测试
所有变量取正常值，只使一个变量按边界值基本思想循环取值

![[Pasted image 20220501201314.png]]
![[Pasted image 20220501201342.png]]

一般性边界值测试：对于一个n变量函数，测试用例数为多少个 :: 4n+1 （min，min+，nom，max-，max） ^1651409346823

健壮性边界值测试：对于一个n变量函数，测试用例数为多少个 :: 6n+1 （min-，min，min+，nom，max-，max，max+） ^1651409346826

![[Pasted image 20220501201714.png]]
![[Pasted image 20220501201720.png]]
**注意：正常值只有1个，避免冗余**
#card-spaced 
^1651409346830


# 白盒测试
什么是白盒测试
按照程序的内部逻辑测试程序，以检查程序中的每条通路是否都能按照预先要求正确工作

如何写测试用例？ #card 
-   用例格式【输入（A，B，C），输出（A，B，C）】
-   要有预期的结果，即输出结果
^1651409346834


## 语句覆盖
![[Pasted image 20220501202309.png]]
使得程序中每个语句至少都能被执行一次

什么是语句覆盖？ #card 
每个语句至少都能被执行一次 
![[Pasted image 20220501202406.png]]
^1651409346837

## 判定覆盖
![[Pasted image 20220501202450.png]]

什么是判定覆盖？ #card 
每个判定至少为TRUE或FALSE各一次 （ace^abd，每条路径都要写测试用例）
![[Pasted image 20220501202558.png]]
^1651409346840

## 条件覆盖
![[Pasted image 20220501203033.png]]
写同时满足条件的测试用例

什么是条件覆盖？ #card 
写同时满足条件的测试用例，并写出全部测试用例
^1651409346843

## 判定/条件覆盖
直接写判定覆盖用例；
满足判断覆盖一定满足条件覆盖；反之不一定。
![[Pasted image 20220501203349.png]]

如何写判定/条件覆盖？ #card 
直接写判定覆盖用例；
^1651409346847

## 路径覆盖
写条件覆盖的全部结果
![[Pasted image 20220501204027.png]]

如何写路径覆盖的测试用例？ #card 
写条件覆盖的全部结果
^1651409346851

如何写白盒测试的覆盖类题目？ #card 
1. 画流程图
2. 写覆盖类型
3. 写执行路径及其测试用例
^1651409346856

## 控制流图
流图G的环复杂度V(G) 如何计算？ #card 
V(G)=判断结点数量（出度=2）+1
^1651409346868

如何写白盒测试的控制流图题目？ #card 
1. 画流程图，控制流图
2. 根据控制流图计算复杂度
3. 写独立路径及其测试用例
^1651409346871

# 补充
- 什么是测试? ::  程序的**执行**过程 ^1651409848720
- 测试的目的是? :: 在于发现错误 ^1651409848730
- 软件测试的直接目标是?  :: 发现软件的错误 ^1651410510530
- 软件测试的期望目标是? ::  检查系统是否满足要求 ^1651410510538
- 软件测试 = 程序测试? :: 错误! ^1651410510544
- 白盒测试的优点是什么? ::  能够对程序内部的特定部位进行覆盖 ^1651410510549
- 覆盖度分析包括哪2个? :: 黑盒测试覆盖度分析;单元测试覆盖度分析 ^1651410510554
- junt4 在每一个测试方法之后执行某些函数,需要使用什么注释? :: @After ^1651410510562
- 黑盒测试需要考虑程序内部结构吗?  :: 不需要,只考虑程序的接口 ^1651410510567
- 确保软件具有更高的可靠性的等价类是指哪个？ :: 无效等价类 ^1651410510571
- 验证程序是否实现某规格的功能的等价类是哪个？ :: 有效等价类 ^1651410510577



CMM/CMMI为满足这个关键过程域的要求需要达到以下4个目标：
目标1：软件质量保证活动是有计划的
目标2：软件产品和活动与适用的标准、规程和需求的符合性要得到客观验证
目标3：相关的小组和个人要被告知软件质量保证的活动和结果
目标4：高级管理者处理在软件项目内部不能解决的不符合问题
marginnote3app://note/12256D1A-3F08-4C3E-B9EF-CD328128FFB9

Title: 软件测试的原则

Date: Mar 21, 2022, Mon, 15:37 

（1）**所有的软件测试都应追溯到用户需求**。

（2）**尽早地和不断地进行软件测试**。

（3）程序员应避免检查测试自己编写的程序。

（4）执行测试计划，尽量避免测试的随意性。

（5）**穷举测试是不可能的。**

（6）**增量测试，由小到大****。**

（7）充分注意群集现象。

（8）妥善保存一切测试过程文档。
