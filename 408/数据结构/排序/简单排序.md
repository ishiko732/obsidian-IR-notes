---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---

# 简单排序
任何仅以交换相邻两元素来排序的算法(例如简单排序)，其平均时间复杂度为? ::$\Omega\left(N^{2}\right)$ ^1663815307210
简单排序指的是哪2个排序? :: 冒泡排序和插入排序 ^1663815307217

## 简单选择排序
```c
void SimpleSelectionSort(ElementType A[],int N){
    int i,j,min;
    for(i=0;i<N-1;i++){
        min=i;
        for(j=i+1;j<N;j++){
            if(A[j]<A[min]){
                min=j;
            }
        }
        if(min!=i){
            Swap(&A[i],&A[min]);
        }
    }
}
```
比较次数$N\times(N-1)/2$
#card-spaced 
^1663815307220


选择排序的思想是==在未排序的序列中选出**最小的元素**和序列的**首位**元素交换,接下来在剩下的未排序序列中再选出最小元素与序列的**第二位元素交换**,依次类推,最后形成从小到大的已排序序列==
^1664693700952


对于n个数的简单选择排序，**最坏**情况下需要交换元素的次数为：==n-1==次
^1664720004663
对于n个数的简单选择排序，**最好**情况下需要交换元素的次数为：==0==次
^1667787433605
简单选择排序的**最好**情况下,时间复杂度为O(==$N^2$==)
^1667787433610
简单选择排序的**最坏**情况下,时间复杂度为O(==$N^2$==)
^1667787433614
选择排序中,每一趟交换一对元素,有序区长度==+1==,无序区长度==-1==,直到整个序列有序,总共进行==n-1==次交换
^1667786715983
选择排序中,关键码的比较次数是==$\sum\limits_{i=1}^n (n-i)=\frac{n(n-1)}{2}$==
^1667786715987
选择排序中,当i=1时,需要进行==n-1==次比较
^1667786715989

## 插入排序
![[Pasted image 20220809192638.png]]
#card-spaced 
^1663815307228

简单插入排序的核心思想是:将待排序的一组序列分为==已排好序列和未排序的两部分==
^1663815307231
简单插入排序是==稳定==(稳定/不稳定)的排序
^1663815307235
简单插入排序的数值相同的两个记录==不会==(会/不会)发生相对位置的改变
^1663815307241

插入排序最好情况是什么时候? 时间复杂度为? :: 顺序T = O( N ) ^1663815307246
插入排序最坏情况是什么时候? 时间复杂度为? :: 逆序 T = O( $N^2$ ) ^1663815307250
插入排序的平均时间复杂度为? ::  T = O( $N^2$ ) ^1663815307252

插入排序在**最好**的情况下,即==正序==,每趟只需与有序区的最后一个关键码进行比较==1==次,移动==2==次关键码
^1667786303955
插入排序在**最好**的情况下,总的比较次数为==n-1==,关键码移动的次数为==2(n-1)==次,时间复杂度为O(==N==)
^1667786303959

插入排序在**最坏**的情况下,即==逆序==,每趟都需要和有序区已有的关键码进行比较,第i个关键码必须与前面==i-1==个关键码和哨兵做比较,每次比较要做==1==次移动关键码
^1667786303962
插入排序在**最坏**的情况下,总的比较次数为==$\sum\limits_{i=2}^n i= \frac{(n+2)(n-1)}{2}$==,关键码移动的次数为==$\sum\limits_{i=2}^n(i+1)=\frac{(n+4)(n-1)}{2}$==次,时间复杂度为O(==$N^2$==)
^1667786303964

插入排序在**平均**的情况下,总的比较次数为==$\sum\limits_{i=2}^n \frac{i}{2}= \frac{(n+2)(n-1)}{4}$==,关键码移动的次数为==$\sum\limits_{i=2}^n\frac{(i+1)}{2}=\frac{(n+4)(n-1)}{4}$==次,时间复杂度为O(==$N^2$==)
^1667786303968

直接插入排序用监视哨兵的作用是==避免每一步都检查是否越界，提升效率==
^1667788675147

## 冒泡排序
![[Pasted image 20220809192455.png]]
#card-spaced 
^1663815307255

冒泡排序第i趟冒泡后能够保证==倒数第i==个元素都是有序的
^1663815307258
冒泡排序如果该轮==没有任何元素发生交换==,则说明序列已经完全有序,不需要继续执行下一趟冒泡,可直接结束
^1663815307261
冒泡排序最好情况是什么时候? 时间复杂度为? :: 顺序T = O( N ) ^1663815307264
冒泡排序最坏情况是什么时候? 时间复杂度为? :: 逆序 T = O( $N^2$ ) ^1663815307269
冒泡排序需要多大的额外空间复杂度? :: O(1) ^1663815307274
冒泡排序的平均时间复杂度为? :: T = O( $N^2$ ) ^1663815307276

冒泡排序是==稳定==(稳定/不稳定)的排序
^1663815307279
冒泡排序的数值相同的两个记录==不会==(会/不会)发生相对位置的改变,因为元素的关键字相等时,==不会==(会/不会)发生交换
^1663815307282
冒泡排序中,通常对n个元素进行冒泡排序要进行==n-1==趟冒泡,第i趟要进行==n-(i+1)==次元素之间的比较
^1664694120052


冒泡排序**最好**情况下,即正序时,比较==n-1==次,移动==0==次,时间复杂度为T = O(==N==)
^1667786427816
冒泡排序**最坏**情况下,即逆序时,第i趟排序需要比较==n-i==次,移动==n-i==次,时间复杂度为T = O(==$N^2$==)
^1667786427819
