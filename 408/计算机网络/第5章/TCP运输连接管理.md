---
tags: 计算机网络 [obsidian]
cards-deck: FSRS::计算机网络
---

TCP是==面向连接==的协议，它基于运输连接来传送TCP报文段。
^1680320213218

![[Pasted image 20230401105301.png]]



- TCP规定同步标志位SYN被设置为1的报文段（例如TCP连接请求报文段和TCP连接请求确认报文段）==不能==携带数据，但要==消耗掉一个序号==。
^1680320213222
- TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号。
	- 如果该报文段不携带数据，则TCP客户进程要发送的下一个数据报文段的序号仍为x+1。

TCP规定同步标志位SYN被设置为1的报文段能否携带数据？::不能。 ^1680320213227
TCP规定同步标志位SYN被设置为1的报文段需要消耗多少个序号？::一个。 ^1680320213233
TCP规定普通的TCP确认报文段是否可以携带数据？::可以。 ^1680320213237
TCP规定普通的TCP确认报文段如果不携带数据会不会消耗序号？::不会。 ^1680320213243
如果TCP的普通确认报文段不携带数据，TCP客户端发送的下一个数据报文段的序号是多少？::x+1。 ^1680320213248


![[Pasted image 20230401105538.png]]

当发送SYN=1,seq=x后,TCP服务器和TCP客户端会进入什么状态?::TCP服务器:同步已接收;TCP客户端:同步已发送 ^1680320213252
当发送SYN=1,ACK=1,seq=y,ack=x+1后,TCP客户端会进入什么状态?::TCP客户端:连接已建立 ^1680320213256
当发送ACK=1,seq=x+1,ack=y+1后,TCP服务器会进入什么状态?::TCP服务器:连接已建立 ^1680320213261


![[Pasted image 20230401105704.png]]
采用“三报文握手”而不是“两报文握手”来建立TCP连接，是为了防止已失效的TCP连接请求报文段突然又传送到了TCP服务器进程，因而导致错误。

为什么要使用“三报文握手”来建立TCP连接？::	为了防止已失效的TCP连接请求报文段突然又传送到了TCP服务器进程，因而导致错误。 ^1680320213266
为什么不能使用“两报文握手”来建立TCP连接？::	因为可能会出现已失效的TCP连接请求报文段被误认为是新的连接请求从而导致错误。 ^1680320213270



![[Pasted image 20230401113113.png]]
- TCP规定终止标志位FIN等于1的TCP报文段即使不携带数据，也要消耗掉一个==序号==。
^1680320213277

MSL是最长报文段寿命（Maximum Segment Lifetime）的英文缩写词，RFC793建议为2分钟。也就是说，TCP客户进程进入时间等待（TIME-WAIT）状态后，还要经过4分钟才能进入关闭（CLOSED）状态。
RFC793对MSL的建议是多少？::2分钟。 ^1680320213282
TCP客户进程进入时间等待（TIME-WAIT）状态后，还要经过多长时间才能进入关闭（CLOSED）状态？::4分钟。 ^1680320213287



## TCP保活计时器
![[Pasted image 20230401113419.png]]

TCP服务器进程每收到一次TCP客户进程发来的数据,则当保活计时器到时后,TCP服务器进程就向TCP客户进程发送一个探测报文段,以后每隔75s发送一次.若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，于是就关闭这个连接。

TCP服务器进程在何时会发送探测报文段？::每次收到TCP客户进程发来的数据，保活计时器到时后。 ^1680320213293
TCP服务器进程发送探测报文段的时间间隔是多少？::	每隔75秒。 ^1680320213297
在何种情况下，TCP服务器进程会认为TCP客户进程所在主机出了故障？::	若连续发送10个探测报文段后仍无TCP客户进程的响应。 ^1680320213302
TCP服务器进程会做出什么反应，若认为TCP客户进程所在主机出了故障？::	关闭这个连接。 ^1680320213307


假设TCP客户与TCP服务器的通信已经结束，TCP客户与TCP服务器之间端到端的平均往返时间为RTT，在t时刻TCP客户请求断开连接，则从t时刻起，TCP服务器释放该连接的最短时间是==1.5==RTT
^1680320313060
