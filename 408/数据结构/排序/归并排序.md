---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---

# [归并排序](zotero://select/library/items/JBWWEBXJ)

归并排序的原理是将大小为N的序列看成==N==个长度为1的子序列,接下来将相邻子序列进行两两归并操作.形成$\frac{N}{2}+1$个长度为2(或1)的有序序列.然后再继续进行相邻子序列的两两归并操作,如此循环直到剩下一个长度为==N==的序列,则该序列为原序列完成排序的结果
^1663899800090

在内排序中一般使用==二==路归并,在外排序中,为减少对外存的访问次数,一般使用==多==路归并,使==m==叉树的带权路径长度最小
^1667786859425


归并排序一般作用于什么排序(内排序/外排序) ? ::外排序 ^1663899800109

如果在==内存==里做排序,不要用归并排序
^1663899800113

归并排序稳定吗? :: 稳定 ^1663899800117

归并排序的时间复杂度? #card 
- T( N ) = O( NlogN ) 
- Msort:O(logN)
- Merge:O(N)
^1663899800120

归并排序需要额外空间复杂度为? :: O(N) (Merge) ^1663899800137

归并排序实际要实现哪2个思想小步骤? #card 
1. 分而之治
2. 合并子列和
^1663899800140
## 分而治之
![[Pasted image 20220809194006.png]]

归并排序的分而治之的时间复杂度? #card 
T( N ) = T( N/2 ) + T( N/2 ) + O( N ) 
=> T( N ) = O( N logN )
其中T(N/2):Msort  O(N):Merge
^1663899800144


## 有序子列的归并
![[Pasted image 20220809193858.png]]
![[Pasted image 20220809193906.png]]

如果两个子列一共有N个元素，则归并(Merge)的时间复杂度是 T ( N ) = ? :: O( N ) ^1663899800147


## 递归实现归并算法
![[Pasted image 20220809194319.png]]
![[Pasted image 20220809194326.png]]
![[Pasted image 20220809194332.png]]
![[Pasted image 20220809194342.png]]



![[Pasted image 20220809194357.png]]
归并排序为什么不在Merge申请空间? #card 
- 在Merge函数内部申请空间,如果不及时释放,会耗费O(NlogN)空间,而在外面申请空间只需要O(N)空间
- 若及时释放,每次还需要耗费O(N)次malloc,free,影响排序效率
^1663899800152

## 非递归实现归并排序
![[Pasted image 20220809194501.png]]
![[Pasted image 20220923102245.png]]

# 虚结点

要时归并排序的带权路径长度最小,则需要满足==(初始归并段数量-1+[虚结点个数]%(n路归并-1)=0==,若不满足则需要补足虚结点到等式成立
^1667784690850
