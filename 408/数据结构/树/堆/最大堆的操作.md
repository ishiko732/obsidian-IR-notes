---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---


## [最大堆的操作](zotero://select/library/items/CNVRI4F8)
### 创建
![[Pasted image 20220809162550.png]]

### 建立
将**已经存在的N个元素**按最大堆的要求存放在一个一维数组中

方法1:通过插入操作，将N个元素**一个个相继插入到一个初始为空的堆中去**，其时间代价最大为O(**NlogN**)。

如果将N个元素一个个相继插入到一个初始为空的堆中去,其时间代价最大为O(==NlogN(插入花费logN)==)
^1661872342558

方法2:在**线性时间复杂度**下建立最大堆。
(1)将N个元素按输入顺序存入，先满足**完全二叉树的结构特性**
(2)调整各结点位置，以满足最大堆的**有序特性**。
![[Pasted image 20220809163057.png]]

一个高度为h的完全二叉树最多可以包含$2^{h}-1$个结点,这些结点的高度和$2^{(h+1)}-1-(h+1)$


在高度为h的堆中，元素个数**最多**是多少个?  #card 
$2^0+2^1+\cdot+2^{(h-1)}=2^{h}-1$
最多是这个堆（包括最底层）是一个完全二叉树
^1661872342589

在高度为h的堆中，元素个数**最少**是多少个?  #card 
$2^0+2^1+...+2^{(h-2)}+1=2^{h-1}-1+1=2^{(h-1)}$
最少是最底层只有一个叶子结点
^1661872342592

含n个元素的堆的高度为==logn==
^1661872342598

一个完全二叉树的结点个数介于==$2^{(h-1)}$==和==$2^{h}-1$==之间
^1661872342603



### 插入
![[Pasted image 20220809162643.png]]
![[Pasted image 20220809162654.png]]
![[Pasted image 20220809162704.png]]


堆的插入操作时间复杂度为O(==logN==)
^1661837048771

如何描述堆的插入过程? #card 
- 从新增的最后一个结点的父结点开始
- 用要插入的元素向下过滤上层结点
```c
bool Insert(MaxHeap H,ElementType X){ // 最大堆的插入
    if(IsFull(H)){
        printf("heap is full\n");
        return false;
    }
    int i=++H->Size;
    for(;H->Data[i/2]<X;i/=2){
        H->Data[i]=H->Data[i/2];
    }
    H->Data[i]=X;
    return true;
}
```
^1661837048778

最大堆当插入的结点大于父结点`(H->Data[i/2]<X)`,应该如何操作? #card 
- 逐步跟父结点交换元素`H->Data[i]=H->Data[i/2];`
- 直到父结点大于插入的元素的结束操作
^1661837048786


### 删除
取出根结点(最大值)元素，同时删除堆的一个结点
![[Pasted image 20220809162741.png]]

**1.替换删除**
**2.比较左右孩子,取最大孩子交换结点**

T (N) = O ( log N )

![[Pasted image 20220809162805.png]]

堆的删除操作时间复杂度为O(==logN==)
^1661837048789

最大堆的删除实际上是? #card 
取出一个根结点的最大值元素,并删除堆中的一个结点
^1661872342607

简单描述一下最大堆的删除过程 #card 
从根结点开始,用最大堆的最后一个元素,从上到下过滤结点
^1661872342614
