---
page-title: "基础 | CSView计算机招聘知识分享"
url: https://www.csview.cn/java/summary.html#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D
date: "2023-03-14 14:47:04"
tags: [obsidian] 
cards-deck: Obsidian::java
---
## 基础

---

### Object类

Object类是Java所有类的父类，包含了所有对象最通用的方法，主要有：

-   **equals**：用于判断两个对象内容是否等同，没有重写的情况下与`==`相同，都是比较地址是否相同，而它设计出来的目的就是为了使程序员通过重写equals自定义比较对象的哪些内容，比如String的equals是比较字符串内容
-   **getClass**：用于获取对象（堆）运行时的类对象（方法区）
-   **hashCode**：用于获取对象的hashCode，主要应用于哈希桶相关容器的定位计算。
-   **toString**：用于获取对象的字符串表示
-   **notify/notifyAll/wait**：用于将线程唤醒/阻塞
-   **clone**：用于拷贝对象

Object类的主要作用是什么？::包含了所有对象最通用的方法。 ^1678776690543
equals方法的作用是什么？::用于判断两个对象内容是否等同。 ^1678776690550
在没有重写equals方法的情况下，它与哪个运算符相同？::与`==`相同。 ^1678776690554
重写equals方法的目的是什么？::使程序员通过重写equals自定义比较对象的哪些内容。 ^1678776690558
String类的equals方法比较的是什么？::比较字符串内容。 ^1678776690564
getClass方法的作用是什么？::获取对象（堆）运行时的类对象（方法区）。 ^1678776690569
hashCode方法的作用是什么？::获取对象的HashCode，主要应用于哈希桶相关容器的定位计算。 ^1678776690573
toString方法的作用是什么？::获取对象的字符串表示。 ^1678776690578
notify/notifyAll/wait方法的作用是什么？::将线程唤醒/阻塞。 ^1678776690583
clone方法的作用是什么？::拷贝对象。 ^1678776690588

### 深浅拷贝

浅拷贝只拷贝对象本身，不对其属性中的引用类型创建新的对象，即拷贝前后的两个对象中的引用指向同一个对象。深拷贝则会为引用类型递归地创建新的对象。对于基本数据类型的属性则都会复制一份。Java中对象的clone方法默认是浅拷贝，如果想深拷贝可以重写clone来实现
![[Pasted image 20230314144729.png]]

浅拷贝只拷贝对象本身吗？::是。 ^1678776690592
浅拷贝是否会创建新的对象？::不会。 ^1678776690598
浅拷贝对引用类型的属性创建新对象吗？::不会。 ^1678776690602
浅拷贝后，拷贝前后两个对象中的引用指向同一对象吗？::是。 ^1678776690607
深拷贝会为引用类型递归地创建什么？::新的对象。 ^1678776690612
深拷贝对基本数据类型的属性会怎么处理？::全部复制一份。 ^1678776690616
Java中的clone方法默认是什么拷贝？::浅拷贝。 ^1678776690620
想实现深拷贝，可以如何做？::重写clone方法。 ^1678776690624


### 拆装箱原理

以Integer为例

`Integer i = 10`

装箱时自动调用Integer的valueOf(int)方法

`int n = i`

拆箱时自动调用Integer的intValue方法 ![image-20210831000034502](https://i.loli.net/2021/09/12/J7RlX4TE58CvBPz.png) Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，它们的参数如果在一定范围内，则会返回cache中已经存在的对象，否则new一个新对象返回

Double、Float的valueOf方法的实现是类似的，这两个没有范围，都返回新对象

```
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

```
public static Double valueOf(double d) {
    return new Double(d);
}
```

Boolean的valueOf都返回两个单例的变量之一

```
public static final Boolean TRUE = new Boolean(true);

public static final Boolean FALSE = new Boolean(false);

public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```

当 `==`运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）


什么是拆装箱？::Java中的数据类型分为基本数据类型和引用数据类型，而拆装箱就是在基本数据类型和引用数据类型之间的转换。 ^1678776690628
什么是装箱？::将一个基本数据类型转换成对应的包装类型，这个过程就叫做装箱。 ^1678776690634
什么是拆箱？::将一个包装类型转换成对应的基本数据类型，这个过程就叫做拆箱。 ^1678776690639
如何进行装箱？::在Java中，可以直接将基本数据类型赋值给对应的包装类型，或者调用包装类型的valueOf()方法。 ^1678776690643
如何进行拆箱？::在Java中，可以直接将包装类型赋值给对应的基本数据类型，或者调用包装类型的xxxValue()方法。 ^1678776690648
Integer、Short、Byte、Character、Long这几个包装类型的valueOf()方法的实现有什么特点？::它们的参数如果在一定范围内，则会返回cache中已经存在的对象，否则new一个新对象返回。 ^1678776690652
Double、Float的valueOf()方法的实现有什么特点？::这两个包装类型没有范围，都会返回一个新对象。 ^1678776690656
Boolean的valueOf()方法返回什么？::返回两个单例的变量之一。 ^1678776690660
当 `==`运算符的两个操作数都是 包装器类型的引用时，会比较什么？::比较指向的是否是同一个对象。 ^1678776690665
当 `==`运算符的两个操作数中有一个是表达式时，会比较什么？::比较的是数值，即会触发自动拆箱的过程。 ^1678776690670



### String相关
**String、StringBuilder和StringBuffer的主要区别**
-   String中的字符数组有final修饰，因此不可变，每次给String类型的引用赋值都是新生成个对象再把该引用指过去，或者是指向字符串常量池中的对象
-   StringBuilder和StringBuffer都继承AbstractStringBuilder，其中的字符数组没有final修饰，可通过令其指向新的字符数组实现各种增删改查操作，二者都有功能相同的各种对其中字符串增删改查的方法，区别是后者的这些方法都加了synchronized修饰，是线程安全的
**各自使用场景**

-   String：操作少量数据
-   StringBuilder：操作大量数据，单线程
-   StringBuffer：操作大量数据，多线程

String中的字符数组是否可变？::不可变。 ^1678776690675
每次给String类型的引用赋值会发生什么？::新生成个对象再把该引用指过去，或者是指向字符串常量池中的对象。 ^1678776690679
StringBuilder和StringBuffer是否可更改其中的字符数组？::是的。 ^1678776690684
StringBuilder和StringBuffer继承自哪个类？::AbstractStringBuilder。 ^1678776690687
StringBuffer的方法是否线程安全？::是的。 ^1678776690692

String、StringBuilder和StringBuffer有什么区别？::	String中的字符数组有final修饰，不可变。StringBuilder和StringBuffer的字符数组没有final修饰，可通过增删改查操作。 ^1678776690697
String引用赋值时会生成新的对象吗？::	是。 ^1678776690702
StringBuilder和StringBuffer的方法有什么区别？::	StringBuilder和StringBuffer都有增删改查等操作方法，不同之处在于后者的这些方法都加了synchronized修饰，是线程安全的。 ^1678776690706
适合在什么情况下使用String？	::适合操作少量数据。 ^1678776690710
适合在什么情况下使用StringBuilder？	::适合操作大量数据，单线程。 ^1678776690714
适合在什么情况下使用StringBuffer？::	适合操作大量数据，多线程。 ^1678776690718

### 接口和抽象类的区别

-   接口方法默认public，抽象类还有protected和default，它们都不能有private，因为生来只为被重写
-   接口只能有static、final变量，抽象类不一定
-   一个类只能继承一个类/抽象类，但可以实现多个接口。一个接口也可以继承多个接口
-   设计上讲，抽象类抽象一类事物，接口抽象一组行为
-   在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。jdk 8 的时候接口可以有默认方法和静态方法功能。Jdk 9 在接口中引入了私有方法和私有静态方法。

一个类能否实现多个接口？::可以。 ^1678776690722
一个接口能否继承多个接口？::可以。 ^1678776690729
接口和抽象类都不允许定义什么类型的方法?::private。 ^1678776690737
在 jdk 7 或更早版本中，接口只能拥有常量变量和抽象方法吗？::是的。 ^1678776690741
在 jdk 8 中，接口是否可以拥有默认方法和静态方法?::是的。 ^1678776690746
在 jdk 9 中，接口是否可以拥有私有方法和私有静态方法?::是的。 ^1678776690750
接口能定义什么类型的变量？::static和final。 ^1678776690754
抽象类能定义什么类型的变量？::protected和default。 ^1678776690757
接口和抽象类在设计上分别抽象什么？::接口抽象一组行为，抽象类抽象一类事物。 ^1678776690761
