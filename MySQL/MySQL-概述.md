---
page-title: "CSView计算机招聘知识分享"
url: https://www.csview.cn/mysql/summary.html
date: "2023-03-14 15:21:37"
tags: [obsidian] 
cards-deck: Obsidian::Mysql
---
### 关系的三个范式是什么？重要

**第一范式(1NF)**：用来确保每列的原子性，要求每列（或者每个属性值）都是不可再分的最小数据单元（也称为最小的原子单元）。

**第二范式(2NF)**：在第一范式的基础上更进一层，要求表中的每列都和主键相关，即要求实体的唯一性。如果一个表满足第一范式，并且除了主键以外的其他列全部都依赖于该主键，那么该表满足第二范式。

**第三范式(3NF)**：在第二范式的基础上更进一层，第三范式是确保每列都和主键列直接相关，而不是间接相关，即限制列的冗余性。如果一个关系满足第二范式，并且除了主键以外的其他列都依赖于主键列，列和列之间不存在相互依赖关系，则满足第三范式。


什么是关系的第一范式？::用来确保每列的原子性，要求每列（或者每个属性值）都是不可再分的最小数据单元。 ^1678779123387
关系的第一范式的目的是什么？::确保每列的原子性。 ^1678779123393
什么是关系的第二范式？::在第一范式的基础上更进一层，要求表中的每列都和主键相关。 ^1678779123398
关系的第二范式要求什么？::要求实体的唯一性。 ^1678779123404
什么是关系的第三范式？::在第二范式的基础上更进一层，确保每列都和主键列直接相关，而不是间接相关。 ^1678779123408
关系的第三范式的目的是什么？::限制列的冗余性。 ^1678779123413
如何满足关系的第一范式？::每列或每个属性值都应该是不可再分的最小数据单元。 ^1678779123418
如何满足关系的第二范式？::除了主键以外的其他列全部都依赖于该主键。 ^1678779123424
如何满足关系的第三范式？::每列都和主键列直接相关，而不是间接相关，且列和列之间不存在相互依赖关系。 ^1678779123429
为什么关系要满足第一范式？::确保每列的原子性，使得数据具有更好的可读性和可维护性。 ^1678779123433
为什么关系要满足第二范式？::确保每条数据的唯一性，减少冗余数据的出现。 ^1678779123438
为什么关系要满足第三范式？::限制列的冗余性，减少数据的重复存储，提高数据的完整性和准确性。 ^1678779123442


### MySQL中varchar和char的区别是什么？掌握

-   char字段的最大长度为255字符，varchar字段的最大长度为65535个字符。
-   char类型如果存的数据量小于最大长度，剩余的空间会使用空格填充，因此可能会浪费空间，所以char类型适合存储长度固定的数据，这样不会浪费空间，效率还比varchar略高；varchar类型如果存到数据量小于最大长度，剩余的空间会留给别的数据使用，所以varchar类型适合存储长度不固定的数据，这样虽然没有char存储效率高，但至少不会浪费空间。
-   char类型的查找效率高，varchar类型的查找效率较低。

MySQL中的varchar和char有什么区别？:: char的最大长度为255字符，varchar的最大长度为65535个字符。 ^1678779123446
char类型和varchar类型在存储数据时有什么不同？:: char类型存储不足最大长度的数据会使用空格填充；varchar类型会留出未使用的空间给其他数据使用。 ^1678779123450
char类型适合存储什么样的数据？:: 长度固定的数据。 ^1678779123456
为什么char类型适合存储长度固定的数据？:: 不会浪费空间，并且存储效率比varchar略高。 ^1678779123461
varchar类型适合存储什么样的数据？:: 长度不固定的数据。 ^1678779123465
为什么varchar类型适合存储长度不固定的数据？:: 不会浪费空间，即使不如char类型存储效率高也更灵活。 ^1678779123470
char类型和varchar类型在查找效率上有什么不同？:: char类型的查找效率高，varchar类型的查找效率较低。 ^1678779123474

### join和left join的区别？掌握

-   join等价于inner join内连接，是返回两个表中都有的符合条件的行。
    
-   left join左连接，是返回左表中所有的行及右表中符合条件的行。
    
-   right join右连接，是返回右表中所有的行及左表中符合条件的行。

join和inner join的关系是什么？::join等价于inner join内连接。 ^1678779123479
join/inner join返回的结果是什么？::返回两个表中都有的符合条件的行。 ^1678779123483
left join返回的是什么？::返回左表中所有的行及右表中符合条件的行。 ^1678779123489
right join返回的是什么？::返回右表中所有的行及左表中符合条件的行。 ^1678779123494


### SQL怎么实现模糊查询？了解

索引 B+ 树是按照索引值有序排列存储的，只能根据前缀进行比较。每一次按照模糊匹配的前缀字典序来进行比较。

什么是索引 B+ 树？::索引 B+ 树是按照索引值有序排列的数据结构。 ^1678779123498
针对模糊查询，B+ 树能否直接进行匹配？::不能。 ^1678779123502
B+ 树如何实现模糊查询？::根据前缀进行比较。 ^1678779123507
B+ 树每次按照什么进行比较来实现模糊查询？::按照模糊匹配的前缀字典序。 ^1678779123511


### select的执行过程？掌握

**连接**：首先客户端和MySQL通过三次握手建立连接，MySQL是基于TCP进行传输的。MySQL服务如果没有启动就会报错。MySQL正常运行的话就去校验用户名和密码，如果认证信息错误也会报错。检验通过之后连接器会获取用户权限并且保存起来，后续的任何操作都会基于开始的读到权限进行判断，即便创建连接之后更改了权限也不会影响已连接的权限。

>长连接解决
第一种，**定期断开长连接**。
第二种，**客户端主动重置连接**。当客户端执行了一个很大的操作后，在代码里调用 mysql\_reset\_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。


MySQL是基于什么进行传输的？::TCP。 ^1678779123514
如果MySQL服务没有启动会发生什么？::会报错。 ^1678779123519
MySQL连接的认证信息如果错误会发生什么？::会报错。 ^1678779123525
连接器在认证通过后会获取什么信息？::用户权限。 ^1678779123529
已连接的权限是否会受到更改的影响？::不会。 ^1678779123532
长连接解决的第一种方法是什么？::定期断开长连接。 ^1678779123538
在客户端执行一个很大的操作后，可以通过什么方法重置连接？::调用 mysql_reset_connection 函数。 ^1678779123544
重置连接后会发生什么？::连接将恢复到刚刚创建完时的状态。 ^1678779123547
重置连接需要重新做什么操作吗？::不需要重新做权限验证。 ^1678779123552
重置连接的作用是什么？::释放内存。 ^1678779123558


**查询缓存**：连接成功后会像MySQL服务中发送SQL语句，MySQL服务收到语句之后会进行解析判断SQL语句的类型。如果是select语句的话就去缓存中查询，看看之前有没有执行过这条select语句。缓存是以k-v形式保存在内存中的，key是SQL语句，value是SQL查询结果。如果缓存中有结果就直接返回给客户端，如果没有命中就继续向下执行。执行完成后的结果会被放入缓存中。

缓存缺点

对于更新比较频繁的表，查询缓存的命中率很低的，只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了寞。

MySQL 8.0 版本直接将查询缓存删掉了，执行一条 SQL 查询语句，不会有查询缓存这个阶段了。


查询缓存的作用是什么？::缓存 SQL 查询结果。 ^1678779123562
查询缓存是如何保存在内存中的？::以 k-v 形式保存。 ^1678779123566
查询缓存的 key 和 value 是什么？::key 是 SQL 语句，value 是 SQL 查询结果。 ^1678779123571
查询缓存的命中率会受到什么影响？::会受到更新操作的影响。 ^1678779123575
对于更新比较频繁的表，查询缓存的命中率为什么很低？::因为一旦有更新操作，该表的查询缓存就会被清空。 ^1678779123579
如果一个查询结果很大，但是还没有被使用，会发生什么？::如果该表有更新操作，该查询缓存就会被清空。 ^1678779123583
MySQL 8.0 版本中还有查询缓存这个阶段吗？::没有，查询缓存被删除了。 ^1678779123588


**SQL解析**：词法分析和语法分析，词法分析是把SQL语句的字符串识别出关键字，方便后续优化，语法分析根据语法规则判断SQL语句是否满足要求。如果SQL语句不对就会报错。

SQL解析包括哪两个部分？::词法分析和语法分析。 ^1678779123592
词法分析的作用是什么？::把SQL语句的字符串识别出关键字，方便后续优化。 ^1678779123596
语法分析的作用是什么？::根据语法规则判断SQL语句是否满足要求。 ^1678779123600
SQL语句如果不符合要求会发生什么？::会报错。 ^1678779123604


**执行SQL**：主要是prepare预处理、optimize优化和execute执行阶段。预处理器检查SQL查询的表或者字段是否存在，如果有\*就将它扩展为SQL的所有的列。优化器是确定SQL语句的执行方案，比方说有索引会选择走了哪个索引。执行器会与存储引擎交互，如果走索引了就将相应索引条件交给存储引擎，存储引擎通过B+树定位数据，如果数据不存在就像执行器返回错误，然后查询结束，找到了就将记录返回给执行数，执行器读到数据之后判断记录是否满足要求，如果满足要求就将数据返回给客户端，否则跳过该数据。如果是全表扫描优化器和存储引擎交互之后存储引擎会访问第一条表中数据，执行器会判断这条数据是否满足条件，满足就发给客户端，然后执行器查询是一个while循环，继续取下一条记录重复判断，直到读完表中所有记录退出循环。如果使用联合索引的话，会在存储引擎层分别判断每个索引是否满足条件，而不先执行回表，所有索引有一个不成立就跳过，否则就返回给Server层回表，这是一个索引下推的过程。

执行SQL主要包括哪几个阶段？::	prepare预处理、optimize优化和execute执行阶段。 ^1678779123608
预处理器负责检查SQL查询的什么内容？::	SQL查询的表或者字段是否存在。 ^1678779123616
预处理器如何处理查询中的`*`号？::扩展为SQL的所有的列。 ^1678779123622
优化器主要用来做什么？::	确定SQL语句的执行方案，比如选择走哪个索引。 ^1678779123626
存储引擎通过什么数据结构定位数据？	B+树。
全表扫描时，存储引擎会访问第一条表中的哪些数据？::	访问第一条表中的数据。 ^1678779123630
使用联合索引会怎么样提高查询效率？	::在存储引擎层分别判断每个索引是否满足条件，而不先执行回表，索引有一个不成立就跳过，否则返回给Server层回表。 ^1678779123634
执行器读到数据之后判断记录是否满足要求，如果满足要求就将数据返回给哪里？::	将数据返回给客户端。 ^1678779123638
执行器查询是一个什么样的循环过程？::	while循环，从查询结果中逐条取记录，重复判断，将满足条件的数据返回给客户端。 ^1678779123643
执行SQL过程中，如果没有找到相应数据，执行器会返回什么结果？	::返回错误。 ^1678779123648

### update的执行过程？掌握

执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取一行记录：

-   如果记录所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；
-   如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。

执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：

-   如果一样的话就不进行后续更新流程；
-   如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；

开启事务，首先要记录相应的 undo log，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。

InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。

在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。

两阶段提交：

-   **prepare 阶段**：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；
-   **commit 阶段**：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；

执行update的过程中，由谁来具体执行？::执行器。 ^1678779123652
执行器在更新数据的过程中，如何获取要更新的记录？::通过主键索引树搜索获取一行记录。 ^1678779123656
如果要更新的记录已经在buffer pool中，是否需要再次读取磁盘上的数据？::不需要，直接返回给执行器更新。 ^1678779123660
如果要更新的记录不在buffer pool中，执行器会进行什么操作？::将数据页从磁盘读入到buffer pool，并返回记录给执行器。 ^1678779123664
执行器拿到聚簇索引记录后，会进行什么操作？::查看更新前后的记录是否一样。 ^1678779123669
如果更新前后的记录一样，执行器是否会进行后续更新流程？::不会。 ^1678779123674
如果更新前后的记录不一样，执行器会将哪些记录作为参数传给InnoDB层？::更新前的记录和更新后的记录。 ^1678779123678
开启事务后，需要生成哪种类型的日志？::undo log。 ^1678779123682
undo log所记录的内容是什么？::被更新的列的旧值。 ^1678779123687
InnoDB层进行更新记录的操作时，会先更新什么数据？::先更新内存，同时标记为脏页。 ^1678779123691
为减少磁盘I/O，脏页不会立即写入磁盘，在什么时候会将脏页写入到磁盘？::后台线程选择一个合适的时机。 ^1678779123694
执行一条更新语句完成后，需要记录哪种类型的日志？::binlog。 ^1678779123698
binlog会在什么时刻刷新到硬盘？::在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。 ^1678779123702
什么是两阶段提交？包括哪两个阶段？::一种将事务从一个状态转移到另一个状态的方式；包括prepare阶段和commit阶段。 ^1678779123707
prepare阶段和commit阶段分别要进行哪些操作？::prepare阶段：将redo log对应的事务状态设置为prepare，然后将redo log刷新到硬盘；commit阶段：将binlog刷新到磁盘，将redo log状态设置为commit。 ^1678779123711

### count性能比较？掌握

count(\*)=count(1)>count(主键)>count(字段)

MySQL 会将星号参数转化为参数 0 来处理，所以count(\*) 和count(1)相等。count(主键)需要判断主键是否为空值；count(字段)会进行全表扫描，效率最差。

count(`*`)与count(1)的结果是否相等？::是。 ^1678779123715
count(主键)的性能如何？::需要判断主键是否为空值，相对较差。 ^1678779123719
何时应避免使用count(字段)？::当需要查询全表时，因为会进行全表扫描，效率最差。 ^1678779123723
MySQL 如何处理count(`*`)参数？::将其转化为参数 0 来处理。 ^1678779123727
哪种count方式效率最高？::count(`*`)或count(1)，效率相同且比count(主键)和count(字段)更高。 ^1678779123730

### drop、truncate和delete的区别？

drop删除整张表和表结构，以及表的索引、约束和触发器；truncate只删除表数据，表的结构、索引、约束等会被保留； delete只删除表的全部或部分数据，表结构、索引、约束等会被保留。

delete语句为DML(data maintain Language)，执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作；truncate、drop是DLL(data define language)，删除行是不能恢复的，并且在删除的过程中不会激活与表有关的删除触发器，执行速度快，原数据不放到rollback segment中，不能回滚。

truncate 和 drop 不支持添加 where 条件，而 delete 支持 where 条件。

执行速度drop>truncate>delete，delete 是逐行执行的，并且在执行时会把操作日志记录下来，以备日后回滚使用，所以 delete 的执行速度是比较慢的；而 truncate 的操作是先复制一个新的表结构，再把原先的表整体删除，所以它的执行速度居中，而 drop 的执行速度最快。

truncate 只能对TABLE；delete可以是TABLE和VIEW。

使用场景

如果想删除表，用**drop**；

如果想保留表而将所有数据删除，和事务无关，用**truncate**即可；

如果和事务有关，或者想触发**trigger**，用**delete**；

如果是整理表内部的碎片，可以用**truncate**跟上reuse stroage，再重新导入/插入数据。

drop会删除表的哪些内容？::表的结构，索引，约束，触发器。 ^1678779123734
truncate会删除表的哪些内容？::表数据。 ^1678779123739
delete会删除表的哪些内容？::全部或部分表数据。 ^1678779123743
delete、truncate和drop的执行顺序是怎样的？::drop>truncate>delete ^1678779123747
delete语句的执行速度是如何的？::较慢，因为是逐行执行，并且会记录日志以备日后回滚使用。 ^1678779123751
truncate操作的执行速度如何？::居中。 ^1678779123755
drop操作的执行速度如何？::最快。 ^1678779123759
drop、truncate和delete在支持where条件上的区别是什么？::truncate和drop不支持，而delete支持。 ^1678779123763
truncate只能对哪些对象进行操作？::TABLE。 ^1678779123766
delete既可以对TABLE进行操作，还可以对哪个对象进行操作？::VIEW。 ^1678779123771
删除表但是保留结构时应该使用哪种方法？::drop。 ^1678779123776
保留表但是删除所有数据时应该使用哪种方法？::truncate。 ^1678779123779
在需要事务回滚或者需要触发trigger的情况下应该使用哪种方法？::delete。 ^1678779123784
如何使用truncate来整理表的碎片？::truncate跟上reuse stroage，再重新导入/插入数据。 ^1678779123789

### MySQL会出现死锁吗，怎么检测死锁？重要

如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。

行锁会发生死锁，表锁不会。死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

解决办法：

-   **设置事务等待锁的超时时间**。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb\_lock\_wait\_timeout 是用来设置超时时间的，默认值时 50 秒。
    
    当发生超时后，就出现下面这个提示：
    
-   **开启主动死锁检测**。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb\_deadlock\_detect 设置为 on，表示开启这个逻辑，默认就开启。当检测到死锁后，就会出现提示。

MySQL 会出现什么样的锁？::行锁和表锁。 ^1678779123793
为什么要尽可能使用索引来优化更新操作？::可以避免全表扫描，减少锁竞争。 ^1678779123801
MySQL 中死锁的必要条件有哪些？::互斥、占有且等待、不可强占用、循环等待。 ^1678779123807
如何解决 MySQL 中的死锁问题？::设置事务等待锁的超时时间、开启主动死锁检测。 ^1678779123810
如何设置 MySQL 中的事务等待锁的超时时间？::使用参数 innodb_lock_wait_timeout。 ^1678779123814
在 MySQL 中设置了事务等待锁的超时时间后，如果超时会发生什么？::会对该事务进行回滚，从而释放锁。 ^1678779123818
如何开启 MySQL 中的主动死锁检测？::将参数 innodb_deadlock_detect 设置为 on。 ^1678779123822
MySQL 中主动死锁检测的作用是什么？::在发现死锁时，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 ^1678779123826
