---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---

## [最短路径算法](zotero://select/library/items/KB9U547Z)
- 在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径
- 这条路径就是两点之间的最短路径(Shortest Path)
- 第一个顶点为==源==点(Source)
^1663229550721
- 最后一个顶点为==终==点(Destination)
^1663229550732

最短路径的描述:在网络中，求两个不同顶点之间的**所有路径**中，{1:边}的{1:权值之和}最{1:小}的那一条路径
^1663229550736

在非网图中,最短路径是指两点之间经历的==边数==最少的路径
^1663229550738


求最短路径算法采用的是BFS还是DFS? :: BFS ^1663229550741

- 单源最短路径问题:从{1:某固定源点}出发，求其到{2:所有其他}顶点的最短路径
^1663229550745
	- (有向)无权图
	- (有向)有权图
- 多源最短路径问题:求{1:任意两}顶点间的最短路径
^1663229550748

### [无权图的单源最短路算法](zotero://select/library/items/KB9U547Z)

无权图的单源最短路算法可以类似于什么算法实现的？ :: BFS算法 ^1663229550751

![[Pasted image 20220809180144.png]]
![[Pasted image 20220809180155.png]]
#card-spaced 
^1663229550764

无权图的单源最短路径算法，dist原点($dist[S]$)应当设置为多少？ :: $dist[S]=0$ ^1663229550767

单源最短路径算法，$dist[W]$表示什么？ #card 
$dist[W] = 源点S到W的当前最短距离$
^1663229550770

单源最短路径算法，$path[W]$表示什么？ #card 
$path[W] = 源点S到W的最短路径邻接于哪个顶点$
^1663229550773


### 有权图的单源最短路
有权图的单源最短路算法可以采用什么算法来实现？ :: dijkstra算法 ^1663229550775

![[Pasted image 20220809180755.png]]

令$S={源点s + 已经确定了最短路径的顶点v_i}$
- 对任一未收录的顶点v，定义$dist[v]$为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径$\left\{s \rightarrow\left(v_{i} \in S\right) \rightarrow \mathbf{v}\right\}$的最小长度
- 若路径是按照递增(非递减)的顺序生成的，则
	- 真正的最短路必须只经过S中的顶点(为什么?)
	- 每次从未收录的顶点中选一个dist最小的收录(贪心)
	- 增加一个v进入S，可能影响另外一个w的dist值!
- $dist[w] = min{dist[w], dist[v] + <v,w>的权重}$

![[Pasted image 20220809181226.png]]
- 方法1:直接扫描所有未收录顶点 – O( |V| )
	- T = O( |V|2 + |E| )
- 方法2:将dist存在最小堆中 – O( log|V| )
	- 更新$dist[w]$的值 – O( log|V| )
	- T = O( |V| log|V| + |E| log|V| ) = O( |E| log|V| )

dijkstra算法的如何找最短路径? #card 
从起点出发,找相邻结点最短的长度选择,依次选择,直到终点.
^1663229550781

dijkstra算法从S出发到图上其余各顶点(终点)V可能达到最短路径长度的初值为:
`dist[v]=?,path[v]=?` #card 
`dist[v]=G[S][V]`
`path[v]=-1`(表示无父顶点) `path[v]=S`表示父顶点是S
^1663229550784

dijkstra算法`collected[v]==false`表示的含义是? :: 表示顶点v未求得最短路径 ^1663229550787


dijkstra算法的变化:$dist[w] =?$ ::  $dist[w] =\min\{dist[w], dist[v] + <v,w>的权重\}$ ^1663229550793
dijkstra算法的变化:$path[w] =?$ ::  $path[w] =V$ ^1663229550797
dijkstra算法的时间复杂度? :: O($|V|^2$) ^1663229550800

![[Pasted image 20220915112634.png]]
![[Pasted image 20220915112648.png]]


### 多源最短路算法
- 方法1:直接将单源最短路算法调用|V|遍
	T = O($|V|^3 + |E|\times|V|$) 对于稀疏图效果好
- 方法2: Floyd算法
	- T = O($|V|^3$)  对于稠密图效果好

Floyd算法的时间复杂度? :: O($|V|^3$) ^1663229550804

- $D^k[i][j]$ = 路径$\{\mathbf{i} \rightarrow\{\boldsymbol{l} \leq \boldsymbol{k}\} \rightarrow \mathbf{j}\}$的最小长度
- $D^0, D^1,\cdots, D^{|V|-1}[i][j]$即给出了i到j的真正最短距离
- 最初的D-1是什么?
- 当$D^{k-1}$已经完成，递推到$D^k$时:
	- 或者![[Pasted image 20220809185147.png]]
	- ![[Pasted image 20220809185152.png]]


![[Pasted image 20220809185222.png]]

![[Pasted image 20220915160304.png]]
#card-spaced 
^1663229550807

Floyd算法若图中存在==负值圈==,则Floyd算法无法得到正确结果
^1663229550810

Floyd算法如何初始化D,P矩阵? #card 
$D^{(-1)}[i][j]=G[i][j]$
$P^{(-1)}[i][j]=-1$
![[Pasted image 20220915160620.png]]
^1663229550812

Floyd算法如何修改$D^{k}[i][j]$矩阵? #card 
$D^{k}[i][j]=\min{D^{(k-1)}[i][j],D^{(k-1)}[i][k]+D^{(k-1)}[k][j]}$
^1663229550815

Floyd算法如何修改$P^{k}[i][j]$矩阵? #card 
若$\min\{ D^{(k-1)}[i][j],D^{(k-1)}[i][k]+D^{(k-1)}[k][j]\}=D^{(k-1)}[i][k]+D^{(k-1)}[k][j]$
则:$P^{k}[i][j]=k$
^1663229550818
