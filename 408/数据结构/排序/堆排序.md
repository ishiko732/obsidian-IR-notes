---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---

# 堆排序
堆排序的核心思想是利用最大堆输出==栈顶==元素,将剩余的元素重新生成==最大堆==,继续输出栈顶元素,重复该过程.需要一个O(==1==)额外空间
^1663811594696

![[heapSort.gif]]
![[Pasted image 20220809194559.png]]

定理:堆排序处理N个不同元素的随机排列的平均比较次数是? :: 2N logN-O(N log logN) ^1663811594700

虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。

堆排序稳定吗? :: 不稳定 ^1663811594703
堆排序的平均时间复杂度为? :: $O(Nlog_2N)$ ^1663811594705
堆排序的最坏时间复杂度为? :: $O(Nlog_2N)$ ^1663811594709
堆排序的额外空间复杂度为? :: O(1) ^1663811594712

![[Pasted image 20220922095310.png]]
#card-spaced 
^1663811594715


- 堆排序在一趟结束后未必能选出一个元素放在其最终位置上? :: 错误,堆排序每趟总能选出一个最大值或者最小值位于根节点； ^1667788026973
-  直接插入排序在一趟结束后**未必**能选出一个元素放在其最终位置上? :: 正确 ^1667788026977
- 归并排序在一趟结束后**未必**能选出一个元素放在其最终位置上? :: 正确 ^1667788026980
- 每一趟排序结束时都至少能够确定一个元素最终位置的方法是==简单选择==排序,==快速==排序,==堆==排序
^1667788026983
