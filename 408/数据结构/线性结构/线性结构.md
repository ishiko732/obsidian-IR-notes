---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---

# [线性表](zotero://select/library/items/ZWQIQPG3)
“线性表(Linear List)”:由同类型数据元素构成有序序列的线性结构
- 表中==元素==个数称为线性表的长度  
^1660269906672
- 线性表没有元素时，称为==空表==  
^1660269906681
- 表==起始==位置称表头，表==结束==位置称表尾
^1660269906684
[[线性表的顺序存储实现]]
[[线性表的链式存储]]
[[广义表]]
[[多重链表]]
[[堆栈]]
[[中缀表达式如何转换为后缀表达式]]
[[队列]]


# 概念
[[408/数据结构/长大/线性结构]]

在链式存储结构中,数据之间的关系是通过==指针==来体现的
^1666523238510

对于顺序存储的线性表,设其长度为n,在任何位置上插入或删除操作都是等概念的,**查找**一个元素时,平均要检索表中的==$\frac{n+1}{2}$==个元素
^1666523238521
对于顺序存储的线性表,设其长度为n,在任何位置上插入或删除操作都是等概念的,插入一个元素时,平均要移动表中的==$\frac{n}{2}$==个元素
^1666523238526
对于顺序存储的线性表,设其长度为n,在任何位置上插入或删除操作都是等概念的,**删除**一个元素时,平均要移动表中的==$\frac{n-1}{2}$==个元素
^1666523238529

在长度为n的顺序表中删除第i个数据元素需要移动==n-i==个元素
^1666523238533
在长度为n的顺序表中插入第i个数据元素需要移动==n-i+1==个元素
^1666523238540
在长度为n的顺序表中查找第i个数据元素需要检索==i==个元素
^1666523238545

根据线性表的链式存储结构中每一个结点包含的**指针个数**,可以将线性表分为==单链表==和==双链表==;根据指针的连接方式可以分为{2:静态}链表和{2:动态}链表
^1666523784531
在长度为n的顺序表中插入一个数据元素,采用顺序存储结构的复杂度为O(==n==),采用链式存储结构的复杂度为O(==1==)
^1666523238550

顺序存储结构是通过==数组下标==表示元素之间的关系的
^1666523615419
链式存储结构是通过==指针==表示元素之间的关系的
^1666523615424

数据结构可以分为==逻辑==结构和==物理(存储)==结构
^1666523615427
线性结构可以分为==线性表==,==队列==,==栈==,==字符串==
^1666523615430

队列是==一端插入,一端删除==的线性表,其运算遵循==先进先出==的原则
^1666523615433
栈是它只能在线性表的==一端==进行插入和删除操作,其运算遵循==先进后出==的原则
^1666523615436
循环队列是队列的一种==顺序==存储结构
^1666523615439

树用双亲表示法,可以很容易找到到**孩子**信息? ::错误,容易找到双亲信息
树用孩子表示法,可以很容易找到**双亲**信息?:: 错误,容易找到孩子信息


# 静态链表
静态链表初始化时,要将头指针设置为==0==;
^1666833729318
静态链表初始化时,要将空闲头指针设置为==1==
^1666833729322
静态链表用什么数值表示空指针? :: -1 ^1666833729325

静态链表SList如何将空闲的单元连成空闲链表? #card 
```c
for(int i=1;i<MaxSize-1;i++){
	SList[i].next=i+1;
}
SList[MaxSize-1].next=-1;//空闲链表结束标记
```
^1666833729331

静态链表SList如何实现插入操作? (代码) #card 
先找到p,再修改空闲头指针
```c
void insert(SList slist,int i,Element x){
    int p=slist->head;
    int s;
    int cnt=0;
    while(slist->dates[p].next!=-1&&cnt<i-1){
        p=slist->dates[p].next;
        cnt++;
    }
    if(slist->dates[p].next==-1){
        printf("插入位置异常\n");
    }else{
        // update avail
        s = slist->avail;
        slist->dates[s].data=x;
        slist->avail=slist->dates[slist->avail].next;
        // update p
        slist->dates[s].next=slist->dates[p].next;
        slist->dates[p].next=s;
    }
}
```
^1666833729334

静态链表SList插入元素的操作顺序? #card 
- 取空闲头指针s,再修改空闲头指针
```c
s = slist->avail;
slist->dates[s].data=x;
slist->avail=slist->dates[slist->avail].next;
```
- 更新指针
	- 修改插入元素s的next为p的next;
	- 再修改p的next为s
```c
slist->dates[s].next=slist->dates[p].next;
slist->dates[p].next=s;
```
^1666833729339

树的双亲表示法属于顺序存储结构吗? ::错误,属于静态链表 ^1666921139432
