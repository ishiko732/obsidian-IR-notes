---
page-title: "Java | CSView计算机招聘知识分享"
url: https://www.csview.cn/java/jvm.html#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F
date: "2023-03-14 15:08:43"
tags: [obsidian] 
cards-deck: Obsidian::java
---
### 内存区域

![image-20210909114511412](https://pic.imgdb.cn/item/63f8b8bdf144a010079d4c87.jpg)

HotSpot在JDK1.8之前方法区就是永久代，永久代就是方法区。

JDK1.8后删除了永久代，改为元空间，元空间在直接内存中。方法区就是元空间，元空间就是方法区。

创建一个线程，JVM就会为其分配一个私有内存空间，其中包括PC、虚拟机栈和本地方法栈

在JDK1.8之前，方法区被称为什么？::永久代。 ^1678778270182
JDK1.8后，方法区被改为什么？::元空间。 ^1678778270188
元空间位于哪个内存区域中？::直接内存。 ^1678778270192
创建一个线程时，JVM会为其分配哪些私有内存空间？::PC、虚拟机栈和本地方法栈。 ^1678778270196

**PC**

用来指示下一个执行的字节码指令，基于这一点就能实现代码的控制流程

为了确保每个线程切换回来都能从上次的位置继续运行，PC必须是线程私有的，切换出去时需保存各自的PC

PC用来指示什么？::下一个执行的字节码指令。 ^1678778270202
PC的作用是什么？::实现代码的控制流程。 ^1678778270206
为了确保线程切换回来能从之前的位置继续运行，PC需要遵循什么规则？::必须是线程私有的。 ^1678778270211
切换出去时需要保存什么信息？::各自的PC。 ^1678778270216

**虚拟机栈**

虚拟机栈中一个栈帧压入就对应一个方法的调用，栈帧弹出就对应方法返回。栈帧中包含：局部变量表、操作数栈、动态链接、方法出口信息。

局部变量表也就是常说的栈内存，用来存储基本类型和引用

HotSpot不支持动态扩展虚拟机栈，在创建线程时就确定了虚拟机栈的最大深度，如果申请不了这么多内存，就会抛出OOM错误，如果线程在运行时调用了很多方法，到达了栈的最大深度，就会抛出SOF错误

本地方法栈和虚拟机栈的区别是什么？::虚拟机栈中是Java方法，本地方法栈中是native方法。 ^1678778270220
在HotSpot中，本地方法栈和虚拟机栈是分开的吗？::不是，已经合并成一个了。 ^1678778270224
本地方法栈中存储的是哪种类型的方法？::native方法。 ^1678778270228

**本地方法栈**

和虚拟机栈相同，区别仅在于虚拟机栈中是java方法，本地方法栈中是native方法，但HotSpot中已经将二者合而为一了。

什么是虚拟机栈？::虚拟机栈是一个方法调用的栈。 ^1678778270233
一个栈帧在虚拟机栈中对应什么？::一个方法的调用。 ^1678778270238
虚拟机栈中的栈帧弹出对应什么操作？::方法返回。 ^1678778270242
虚拟机栈中的栈帧包含哪些信息？::局部变量表、操作数栈、动态链接、方法出口信息。 ^1678778270250
局部变量表用来存储什么类型的数据？::基本类型和引用。 ^1678778270253
HotSpot虚拟机栈支持动态扩展吗？::不支持。 ^1678778270258
在创建线程时，如何确定虚拟机栈的最大深度？::在创建线程时就确定。 ^1678778270262
当申请的虚拟机栈内存超过最大深度时，会发生什么错误？::OOM错误。 ^1678778270267
在运行时，如果线程到达了虚拟机栈的最大深度，会发生什么错误？::SOF错误。 ^1678778270271

**堆**

JVM中最大的一块内存空间，所有对象实例和数组都在这里分配内存，所有线程共享堆内存。

JDK1.7开始默认开启了逃逸分析，如果一个对象只在一个线程中被引用了，则该对象可以直接在栈上分配内存空间。

堆也叫GC堆，是垃圾回收的主要区域。为了便于垃圾回收，JDK1.8之前将堆分为三个部分：

1.  新生代
2.  老年代
3.  永久代

而1.8之后将永久代删除了，取而代之的是元空间，元空间则在直接内存中。

此外，新生代还细分为eden、from survivor（s0）和to survivor（s1）

当新对象实例产生时，年龄为0，首先被分配在eden里，在一次gc后，如果还存活，就被扔到survivor里，并且年龄+1，当年龄增加到一定程度后就被扔到老年代里。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

什么是堆？::JVM中最大的一块内存空间，所有对象实例和数组都在这里分配内存，所有线程共享堆内存。 ^1678778270276
堆也叫什么？::GC堆。 ^1678778270284
逃逸分析的作用是什么？::如果一个对象只在一个线程中被引用了，则该对象可以直接在栈上分配内存空间。 ^1678778270289
JDK1.8中永久代被什么替代？::元空间（在直接内存中）。 ^1678778270292
堆被分为哪三个部分？::新生代、老年代、永久代（在JDK1.8之前）。 ^1678778270296
新生代又被细分为什么？::eden、from survivor（s0）、to survivor（s1）。 ^1678778270301
新对象实例在堆中的哪个区域分配？::eden。 ^1678778270306
当新对象实例的年龄增加到一定程度时，会被扔到哪个区域？::老年代。 ^1678778270310
如何设置对象从新生代晋升到老年代的年龄阈值？::通过参数-XX:MaxTenuringThreshold设置。 ^1678778270314
堆是哪个区域的主要区域？::垃圾回收的主要区域。 ^1678778270319

**方法区**

存放被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

1.8之前是永久代，属于堆内存。1.8之后是元空间，属于直接内存。

永久代受JVM创建时分配的最大堆内存限制，而元空间则受系统内存限制，可以存储更多。

什么是方法区？	::存放被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据的区域。 ^1678778270323
1.8之前的方法区属于哪一种内存？::	堆内存的一部分，称为永久代。 ^1678778270327
1.8之后的方法区属于哪一种内存？::	直接内存的一部分，称为元空间。 ^1678778270330
永久代的大小受到哪种限制？::	JVM 创建时分配的最大堆内存限制。 ^1678778270336
元空间的大小受到哪种限制？::	系统内存的限制。 ^1678778270340
在以上两种内存中，哪一种可存储更多的数据？::	元空间。 ^1678778270344

**常量池**

分为字符串常量池和运行时常量池

1.8之后字符串常量池在堆中，而运行时常量池在元空间

什么是常量池？::常量池是Java虚拟机中的一段用于存放编译期生成的各种字面量和符号引用的区域。 ^1678778270348
常量池分为哪两种？::字符串常量池和运行时常量池。 ^1678778270352
1.8之后字符串常量池存放在哪个区域？::堆中。 ^1678778270356
1.8之后运行时常量池存放在哪个区域？::元空间。 ^1678778270360

**直接内存**

在JVM进程的内存空间之外，属于系统内存。

JVM可通过native方法对其进行直接操作，而无需在使用时将其拷贝到JVM内存区。

什么是直接内存？::	在JVM进程的内存空间之外的系统内存。 ^1678778270363
JVM能否直接操作直接内存？::	可以。 ^1678778270370
为什么JVM可以直接操作直接内存？	::可以通过native方法进行操作，无需拷贝到JVM内存区。 ^1678778270374

### 对象创建过程

![Java创建对象的过程](https://pic.imgdb.cn/item/63f8b9aef144a010079ea749.jpg)

Java创建对象的过程

1.  **类加载检查：**
    
    JVM遇到一条new指令时，先检查能不能在常量池中定位到该类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有就要先进行类加载。类已被加载就通过检查。
    
2.  **分配内存：**
    
    类加载检查通过后JVM为新对象分配内存，对象所需的内存大小在类加载完成后就确定了，JVM会在堆中按照**指针碰撞**或**空闲列表**的方式为对象划分出一块空间，选择哪种方式会根据垃圾收集器的算法而定。此外，内存分配还要保证线程安全，JVM采用**CAS+失败重试**或**TLAB**的方式保证线程安全。
    
    CAS+失败重试：乐观锁的一种实现，每次占用资源不加锁，而是不断尝试占用。
    
    TLAB：线程创建时预先在堆中给线程分配一块内存，称为TLAB，专门用来存放该线程运行过程中创建的对象，而TLAB满了时，采用上述CAS在堆的其它内存中分配
    
3.  **初始化零值：**
    
    将对象的字段设为默认零值，不包括对象头
    
4.  **设置对象头：**
    
    在对象头中设置这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、是否启用偏向锁等信息
    
5.  **执行init方法：**
    
    初始化对象，即按照程序员写的构造方法给对象进行初始化。

Java创建对象的过程由哪几部分组成？::由类加载检查、分配内存、初始化零值、设置对象头以及执行init方法五个部分组成。 ^1678778270378
Java创建对象时第一步是做什么？::类加载检查，包括检查常量池定位到该类的符号引用和该类是否已被加载、解析和初始化。 ^1678778270385
Java创建对象时会使用哪两种内存分配方式？::指针碰撞和空闲列表。 ^1678778270389
为何需要保证Java对象创建时的线程安全？::因为多线程同时创建对象可能会导致内存空间分配的冲突和错误。 ^1678778270393
Java对象创建时需要设置哪些对象头信息？::设置对象属于哪个类，如何找到类的元数据信息，对象的哈希码、GC分代年龄、是否启用偏向锁等信息。 ^1678778270397
Java对象创建过程中会初始化哪些值？::会初始化零值，不包括对象头。 ^1678778270402
Java对象创建过程中最后一步是做什么？::执行init方法，即按照程序员写的构造方法对对象进行初始化。 ^1678778270406

### GC

**内存分配与回收**

新对象优先被分配在eden里，年龄设置为0，经历第一次gc后如果还存活，就被扔到survivor中，并且年龄+1，随后每经历一次gc如果还存活就年龄+1，如果年龄超过了上限（默认15），就被扔到老年代中。通过-XX：MaxTenuringThreshold设置上限。

此外，JVM还有动态年龄判定机制：如果在survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到年龄超过上线。

如果是过大的对象，为了避免其来回复制，可以在创建时直接扔到老年代里。通过-XX：PretenureSizeThreshold设置，只支持Serial和ParNew。

![image-20210911183213177](https://i.loli.net/2021/09/12/MdbG2zIoR4FpKNr.png)
hotspot中gc分为两类：部分收集partial gc和全收集full gc。

部分收集又分minor gc、major gc和mixed gc

minor gc：只对新生代进行回收

major gc：只对老年代进行回收（有时也指代full gc）

mixed gc：对整个新生代和部分老年代进行回收

全收集full gc：对整个堆和方法区（hotspot中的元空间）进行回收

新对象被分配在哪里？::在eden里。 ^1678778270410
新对象的年龄初始值是多少？::0。 ^1678778270414
新对象在什么情况下会被扔到survivor中？::在经历第一次gc后，如果还存活。 ^1678778270419
对象在survivor中每经历一次gc，年龄会发生什么变化？::年龄+1。 ^1678778270423
对象的年龄超过多少就会被扔到老年代中？::默认15，可以通过-XX:MaxTenuringThreshold设置。 ^1678778270427
动态年龄判定机制是什么？::如果在survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。 ^1678778270432
过大的对象会被直接扔到哪里里？::老年代。 ^1678778270438
如何设置过大对象的阈值？::通过-XX:PretenureSizeThreshold设置，只支持Serial和ParNew。 ^1678778270442
hotspot中gc分为哪两类？::部分收集（partial gc）和全收集（full gc）。 ^1678778270445
部分收集又分为哪三种？::minor gc、major gc和mixed gc。 ^1678778270450
哪种gc会对整个堆和方法区进行回收？::全收集（full gc）。 ^1678778270454

**判别对象、常量、类死亡的方法**

-   **对象**

1.  **引用计数法：**
    
    对象中设置一个引用计数器，每当该对象被引用时，引用计数器就会+1，失去一个引用时就会-1。引用计数器为0时就代表已经死亡，不会再被引用了。这种判别方式有个缺点，如果两个对象互相引用，但又没有外界对它们的引用，则它们引用计数都为1，会一直存在，但没有意义。
    
2.  **可达性分析法：**
    
    设置一组对象为**gc roots**，如果一个对象没有能到达任何一个gc root的引用链，则判别这个对象死亡。一般一个线程启动后并列创建的一组对象会构成gc roots，gc roots内部引用的对象就是非gc root。![image-20210911220120397](https://i.loli.net/2021/09/12/Mncmzl8OVLdvBHE.png)
    

-   **常量**

没有被任何对象引用时就是废弃的

-   **类**

同时满足如下三点就是无用的类

1.  该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2.  加载该类的 ClassLoader 已经被回收。
3.  该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类 的方法。

对象判别的两种方法是什么？::引用计数法和可达性分析法。 ^1678778270457
引用计数法的缺点是什么？::如果两个对象互相引用，但没有外界对它们的引用，则它们引用计数都为1，会一直存在，但没有意义。 ^1678778270461
可达性分析法中的gc roots指什么？::一组对象。 ^1678778270467
当一个对象没有能到达任何一个gc root的引用链时会怎样？::被判定为死亡。 ^1678778270471
什么情况下，一个常量被认为是废弃的？::没有被任何对象引用时。 ^1678778270475
什么条件下，一个类被认为是无用的？::该类所有的实例都已经被回收；加载该类的ClassLoader已经被回收；该类对应的java.lang.Class对象没有在任何地方被引用。 ^1678778270479

**引用类型都有哪些？**

1.  **强引用**
    
    ```
    Object strong = new Object();
    ```
    
    一个对象如果被引用，且最高级别是强引用，就不会被回收。
    
2.  **软引用**
    
    ```
    SoftReference<Object> soft = new SoftReference<>(new Object());
    ```
    
    一个对象如果被引用，且最高级别是软引用，发生gc时内存足够就不会被回收，内存不够就会被回收。
    
3.  **弱引用**
    
    ```
    WeakReference<Object> weak = new WeakReference<>(new Object());
    ```
    
    一个对象如果被引用，且最高级别是弱引用，发生gc时不管内存够不够都会被回收。
    
4.  **虚引用**
    
    ```
    ReferenceQueue<Object> queue = new ReferenceQueue<>();
    PhantomReference<Object> phantom = new PhantomReference<Object>(new Object(), queue);
    ```
    
    虚引用创建时必须搭配ReferenceQueue。
    
    一个对象如果被引用，且最高级别是虚引用，就等于没有被引用，发生gc时不管内存够不够都会被回收。
    
    虚引用看起来和弱引用没啥区别，只是必须搭配ReferenceQueue。
    
    用虚引用的目的一般是跟踪对象被回收的活动。
    
5.  **ReferenceQueue**
    
    软引用、弱引用和虚引用在创建时都可以关联一个ReferenceQueue，其中虚引用必须关联，其余两个可选关联。
    
    关联了ReferenceQueue的引用所引用的对象在被回收内存之前，这个引用会被JVM加入到关联的ReferenceQueue中。通过这样的机制，我们就能通过监听该队列，在对象内存被回收前进行一些自定义处理。
    

在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。


引用类型有哪些？::强引用、软引用、弱引用、虚引用。 ^1678778270483
强引用的特点是什么？::只要对象被强引用，就不会被回收。 ^1678778270487
软引用的特点是什么？::如果内存够用，软引用不会被回收，否则会被回收。 ^1678778270491
弱引用的特点是什么？::无论内存是否够用，弱引用都会被回收。 ^1678778270495
虚引用的特点与弱引用有何不同？::虚引用创建时必须搭配ReferenceQueue，且对象被回收时不会立即被回收。 ^1678778270500
使用哪种引用类型可以加速垃圾回收速度？::软引用。 ^1678778270504
关联ReferenceQueue有哪些好处？::能够在对象被回收前进行自定义处理。 ^1678778270508
在程序设计中最少使用的两种引用类型分别是哪两种？::弱引用和虚引用。 ^1678778270511

**GC算法有哪些？**

-   **标记-清除** ：先标记上所有存活的对象，再一次性回收掉没被标记的，这是最基础的算法，后面的几个都是对其效率和空间碎片问题做了优化。 碎片问题会导致都是小空隙，装不下大对象，而如果将对象整理起来就会空出更大的空隙。
    
-   **复制** ：将内存分为两块，只用其中一块，当用的这一块满了后，还是对其中存活的对象进行标记，然后将这些被标记的逐个复制到另一块内存，最后将剩余的死亡对象一次性回收，说白了就是两块内存来回倒。由于一次gc需要处理的总内存变小了，效率也就提升了。
    
-   **标记-整理** ：和标记-清除一样，先标记存活对象，然后将它们堆到一端，最后回收掉末端以外的对象。
    
-   **分代收集** ：新生代死亡对象比较多，一般用复制算法。老年代死亡对象比较少，一般用标记-清除或标记-整理算法

GC算法中的标记-清除算法如何实现？:: 先标记存活对象，再一次性回收没被标记的对象。 ^1678778270516
GC算法中的复制算法如何实现？:: 将内存分为两块，只用其中一块，当用的这一块满了后，对其中存活的对象进行标记，然后将这些被标记的逐个复制到另一块内存，最后回收剩余的死亡对象。 ^1678778270520
GC算法中的标记-整理算法如何实现？:: 先标记存活对象，然后将这些存活对象堆到一端，回收掉末端以外的对象。 ^1678778270524
GC算法中的分代收集算法是如何实现的？:: 根据不同对象的寿命将内存分为新生代和老年代两个部分，新生代采用复制算法，老年代采用标记-清除或标记-整理算法。 ^1678778270528


### 类加载流程

**加载**

将字节流读入JVM内存，在方法区存储为一个数据结构，同时创建一个对应的Class对象供程序访问。

**验证**

一共4步：

1.  文件格式验证
    
    验证读进来的字节流是否符合Class标准格式。
    
2.  元数据验证
    
    格式对了之后，验证一下里边的数据合不合理。
    
    比如：这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
    
3.  字节码验证
    
    分析类的方法体（Class文件中的Code属性），确保方法在运行时不会危害虚拟机。
    
4.  符号引用验证（发生在解析阶段）
    
    检查常量池中引用的外部类是否存在，是否可以正常访问。
    

**准备**

类变量（静态变量）分配内存并设置初值

其中如果是final修饰的，意味着在Class文件中，该字段的属性表中存在ConstantValue属性，此时初值设置为代码里写的。

如果不是，就设置为零值，等到初始化阶段再赋值。

**解析**

把符号引用（地址无关）转化为直接引用（地址相关）

**初始化**

执行clinit方法，这里要注意不是构造方法，而是执行静态语句，包括静态变量赋值和静态块


类加载的第一步是什么？::加载。 ^1678778270533
加载过程中，字节流被存储在哪里？::方法区。 ^1678778270537
加载过程中，同时创建一个什么对象？::Class对象。 ^1678778270541
类加载的第二步是什么？::验证。 ^1678778270544
类加载中的验证过程包括哪些步骤？::文件格式验证、元数据验证、字节码验证、符号引用验证。 ^1678778270548
验证过程中，文件格式验证的作用是什么？::验证读进来的字节流是否符合Class标准格式。 ^1678778270552
验证过程中，元数据验证的作用是什么？::验证类里的数据是否合法。 ^1678778270556
验证过程中，字节码验证的作用是什么？::确保方法在运行时不会危害虚拟机。 ^1678778270561
验证过程中，符号引用验证发生的阶段是什么？::解析阶段。 ^1678778270564
准备阶段做了什么？::类变量（静态变量）分配内存并设置初值。 ^1678778270569
在准备阶段中，final修饰的变量初值在哪里取得？::属性表中的ConstantValue属性。 ^1678778270573
在准备阶段中，如果变量不是final修饰的，其初值被设置为什么？::零值。 ^1678778270576
类加载的第四步是什么？::解析。 ^1678778270580
解析过程完成了什么任务？::把符号引用转化为直接引用。 ^1678778270584
初始化过程中执行什么方法？::clinit。 ^1678778270588
在初始化阶段，静态语句包括哪些内容？::静态变量赋值和静态块。 ^1678778270592
在初始化阶段，执行的是哪种方法？::clinit方法。 ^1678778270596
