---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---


## [队列](zotero://select/library/items/VYFSPTVM)
队列(Queue):具有一定操作约束的线性表  
- 插入和删除操作:只能在一端插入，而在另一端删除。
- 数据插入:入队列(AddQ)
- 数据删除:出队列(DeleteQ)
- 先来先服务  
- 先进先出:FIFO
![[Pasted image 20220801211301.png]]

队列的特点是? :: 先进先出 ^1660271088953
入队列用什么英文表示? :: AddQ ^1660271088957
出队列用什么英文表示? :: DeleteQ ^1660271088961


### 队列的顺序存储实现
队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成
![[Pasted image 20220801211330.png]]
![[Pasted image 20220801211344.png]]
![[Pasted image 20220801211404.png]]


利用循环队列堆栈空的条件是? :: Front=Rear ^1660271088964
利用循环队列堆栈满的条件是? :: `(Rear+1)%Q->MaxSize==Front`  ^1660271088967
循环队列已知最大存储空间MaxSize,队内元素的个数x为? :: `(Rear-Front+X)%MaxSize` ^1664549123210
循环队列已知最大存储空间MaxSize,元素的个数为? :: `(Rear-Front+MaxSize)%MaxSize` ^1664549123210

![[Pasted image 20220812102303.png]]
为什么用循环队列会出现无法区分空,满的情况?为什么? #card 
当F=R时,队列可能为空或者满;
因为Rear和Front之间的差距最多为n种,队列元素个数总共有n+1种,因此无法仅靠Front,Rear来区分n+1种情况
^1660271088970

利用循环队列添加元素,先动指针还是先添加元素? #card 
先动指针再添加元素
![[Pasted image 20220813230438.png]]
^1660403129604

利用循环队列删除元素,先动指针还是先删除元素? #card 
先动指针再删除元素
![[Pasted image 20220813230504.png]]
^1660403129613

利用循环队列少用一个元素空间,应当如何设置Front和Rear? #card 
```c
Queue CreateQueue(int MaxSize){
    Queue Q=(Queue)malloc(sizeof(struct QNode));
    Q->Data=(ElementType*)malloc(MaxSize*sizeof(ElementType));
    Q->Front= 0;
    Q->Rear = 0;
    return Q;
}
```
^1660403228619

循环队列的引入的目的是为了克服==假溢出==的情况
^1664549123213

### 队列的链式存储实现
队列的链式存储结构也可以用一个==单链表==实现。插入和删除操作分别在链表的两头进行;
^1660271088974

队列指针front和rear应该分别指向链表的哪一头? #card
队列的头必须指向链表的头结点,因为Front可以做删除操作,尾指针不能做删除操作(需要知道前一个结点的指针,但是是单链表无法知道)
Rear可以做插入操作,跟stack一样
^1660271088977

![[Pasted image 20220801211514.png]]
![[Pasted image 20220801211521.png]]

链队列如何判断队列是否为空? #card 
`rear==front`
^1666512489376


## 现象
随着顺序队列的入队和出队不断进行,队列中的元素在数组中呈现“==单向移动性==”的情况,会出现==假溢出==的现象
^1666510942117

## 双端队列

双端队列如何实现**队头的入队**? #card 
- 需要判断是否队列已满
- 先存数据,再将front指针在循环意义上-1
```c
data[front]=x;
front=(front-1+Q->MaxSize)%Q->MaxSize;
```
^1666512072986

双端队列如何实现队头的入队(代码) #card 
```c
void enQueueFront(Queue Q,Element X){
	if((Q->rear+1)%Q->MaxSize==Q->front){ // Queue是否已满
		error;
	}else{
		data[front]=x;
		front=(front-1+Q->MaxSize)%Q->MaxSize;
	}
}
```
^1666512106926

双端队列如何实现**队尾的出队**? #card 
- 需要判断队列是否为空
- 先**暂存**数据,再将rear指针在循环意义上-1,然后把暂存的数据返回
```c
x=data[rear];
rear=(rear-1+Q->MaxSize)%Q->MaxSize;
```
^1666512240928


双端队列如何实现队尾的出队(代码) #card 
```c
void deQueueRear(Queue Q,Element X){
	if((Q->front==Q->rear){ // Queue是否为空
		error;
	}else{
		x=data[rear];
		front=(rear-1+Q->MaxSize)%Q->MaxSize;
		return x;
	}
}
```
^1666512240935
