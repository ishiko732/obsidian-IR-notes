---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---


## [集合的表示](zotero://select/library/items/TKNG7UTG)

- 集合运算:交、并、补、差，判定一个元素是否属于某一集合
- 并查集:集合并、查某元素属于什么集合
- 并查集问题中集合存储如何实现?
- 可以用**树**结构表示集合，树的每个结点代表一个集合元素

![[Pasted image 20220809164523.png]]
![[Pasted image 20220809164531.png]]



如何利用二叉树来表示集合? #card 
利用双亲表示法(孩子指向双亲)来表示结点,用负数来表示根结点,非负数表示父结点
```c
typedef struct {
ElementType Data;
int Parent;
} SetType;
```
^1661916058290

![[Pasted image 20220809164620.png]]

如何利用数组来表示集合? #card 
利用下标表示元素所在的位置,内容指向父结点,其中父结点是小于0的负数
^1661916058309

## 集合的运算
### 查找
查找某个元素所在的集合(用根结点表示)
![[Pasted image 20220809164659.png]]

```c
SetName Find(SetType S,ElementType X){ // 普通查找
    for(;S[X]>=0;X=S[X]);
    return X;
}
```



```c
SetName Find(SetType S,ElementType X){ // 压缩路径
    if(S[X]<0){
        return X;
    }else{
        return S[X]=Find(S,S[X]);
    }
}
```




### 并运算
- 分别找到X1和X2两个元素所在集合树的根结点
- 如果它们不同根，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标。
![[Pasted image 20220809164739.png]]
 为了改善合并以后的查找性能，可以采用小的集合合并到相对大的集合中。 (修改Union函数)

```c
void Union(SetType S,SetName Root1,SetName Root2){
    if(S[Root2]<S[Root1]){ // 若Root2大于Root1 (这里Root1,Root2带有负号)
        S[Root2]+=S[Root1]; // 合并小树root1
        S[Root1]=Root2; //Root1 指向 Root2(小树指向大树)
    }else{
        S[Root1]+=S[Root2];
        S[Root2]=Root1;
    }
}
```

