---
tags: 数据结构 [obsidian]
cards-deck: 考研::数据结构
---

## 散列表
### [散列查找法的两项基本工作](zotero://select/library/items/ETGUMQNL)
- ==计算位置==:构造散列函数确定关键词存储位置;
^1662430827996
- ==解决冲突==:应用某种策略解决多个关键词位置相同的问题
^1662430828025
- 时间复杂度几乎是常量:O(==1==)，即查找时间与==问题规模==无关!
^1662430828032

散列表查找失败次数如何定义? #card 
查找失败是指你要找的这个数不在哈希表中，所以只要一直查找到散列表中第一个关键字为空的地址即可。
^1664718612618



### “散列(Hashing)” 的基本思想
(1)以关键字key为自变量，通过一个确定的函数h(散列函数)， 计算出对应的函数值h(key)，作为数据对象的存储地址。

(2)可能不同的关键字会映射到同一个散列地址上，即$h(key_i) = h(key_j)$(当$key_i\ne key_j$)，称为“冲突(Collision)”。 ----需要某种冲突解决策略

![[Pasted image 20220809200539.png]]

 装填因子(Loading Factor):设散列表空间大小为m，填入表中元素个数是n，则称α= {n/m}为散列表的装填因子
^1662430828038
	 α=11 / 17 ≈ 0.65。

### [散列函数的构造方法](zotero://select/library/items/GXZ3PGQ8)
#### 一个“好”的散列函数一般应考虑下列两个因素:
1. ==计算简单==，以便提高转换速度;
^1662430828043
2. 关键词对应的地址空间分布==均匀==，以尽量减少==冲突==。
^1662430828046

### 数字关键词的散列函数构造

#### 直接定址法
取关键词的某个线性函数值为**散列**地址，即
h(key) =? ::h(key) = $a \times key + b (a、b为常数)$ ^1662430828052


#### 除留余数法
散列函数为:h(key) =? ::  h(key) =key mod p ^1662430828056

假设散列表长为TableSize(由关键词集合n和允许最大装填因子决定),一般选取p为{1:最大}的{1:素}数.
^1662430828059

如果p<TableSize,则意味着{1:`[p,Tablesize-1]`}无法通过{2:散列}函数直接映射到,不用担心空间被浪费了,在{3:冲突发生}时就可能会用到.
^1662430828066

![[Pasted image 20220809201031.png]]

#### 数字分析法
分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址
![[Pasted image 20220809201142.png]]

#### 折叠法
把关键词分割成{1:位数相同}的几个部分，然后{1:叠加}
^1662430828077
![[Pasted image 20220809201220.png]]

#### 平方取中法
![[Pasted image 20220809201245.png]]
平方以后取==中间几位==数
^1662430828080

### 字符关键词的散列函数构造
![[Pasted image 20220809201329.png]]
#card-spaced 
^1662430828088
